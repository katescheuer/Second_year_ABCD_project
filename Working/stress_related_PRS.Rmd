---
title: "Stress-related PRS"
output: html_document
date: "2024-02-12"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

setwd("C:/Users/Kate Scheuer/OneDrive - UW/Desktop/Lab/Second_year_ABCD_project/Working")

```

### Import data, load libraries

```{r import data, load libraries, echo=FALSE}

### load libraries ####
library(readxl)
library(tidyverse)
library(GENESIS)
library(lme4)
library(Matrix)
library(misty)
library(lmerTest)
library(moments)
library(robustlmm)

### avoid scientific notation ####
options(scipen=999) ## forces full display of results, all digits
# to change it back to scientific notation, use: options(scipen=0)


### import data ####

## ABCD data
demo <- read.csv("abcd_p_demo.csv",header=T) # demographics
# income <- read_xlsx("ABCD_SES_incomeneeds.xlsx")
meta <- read.csv("abcd_y_lt.csv",header=T) #site id, interview age
cbcl <- read.csv("mh_p_cbcl.csv",header=T) # cbcl
ksads_y <- read.csv("mh_y_ksads_ss.csv",header=T) #youth-reported ksads
ksads_p <- read.csv("mh_p_ksads_ss.csv",header=T) #parent-reported ksads
ksads_lifetime <- read.csv("ABCD_Baseline_T1_T2_T3_T4_KSADS_Lifetime_Diagnoses.csv") #lifetime ksads diagnoses

## federal poverty data from https://aspe.hhs.gov/topics/poverty-economic-mobility/poverty-guidelines
poverty_info <- read.csv("federal_poverty_info.csv",header=T)

## PRS 
prs_no_mhc <- read.table("StressPRS.profile",header=T) #not including any snps in mhc
prs_one_mhc <- read.table("StressPRS_w_MHC.profile",header=T) #including one snp in mhc w highest effect size
prs_all_mhc <- read.table("StressPRS_w_one_MHC.profile",header=T) #include all snps in mhc

## genetic relatedness matrices (GRMs)
all_grm <- readRDS(file = "ABCD_All_PCRel_grm_sparse.rda") # all ancestries
afr_grm <- readRDS(file = "ABCD_Afr_PCRel_grm_sparse.rda") # african ancestry
amadmix_grm <- readRDS(file = "ABCD_AmerAdmix_PCRel_grm_sparse.rda") # american admixed ancestry
eur_grm <- readRDS(file = "ABCD_Eur_PCRel_grm_sparse.rda") # european ancestry

## ancestry groupings
afr_gp <- read_xlsx("ABCD_RF_Afr_Grouping.xlsx")
amadmix_gp <- read_xlsx("ABCD_RF_AmerAdmix_Grouping.xlsx")
eur_gp <- read_xlsx("ABCD_RF_Eur_Grouping.xlsx")

```

### Group all like files into one data frame each, basic data cleaning

```{r group data, echo=FALSE}

### make one column each for ever having ksads diagnosis ####
ksads <- select(ksads_y,c("src_subject_id","eventname",
                          
                         "ksads_14_854_t", # past adhd baseline to year 2
                         "ksads2_14_810_t", # past adhd year 3+
                         "ksads_14_853_t", # current adhd baseline to year 2
                         "ksads2_14_809_t", # current adhd year 3+
                         "ksads2_14_812_t", # full remission adhd year 3+
                         "ksads_14_855_t", # partial remission adhd baseline to year 2
                         "ksads2_14_811_t", # partial remission adhd year 3+
                         "ksads2_14_813_t", # other adhd year 3+
                         "ksads_14_856_t", # unspecified adhd baseline to year 2
                         
                         "ksads2_10_828_t", # past gad year 3+
                         "ksads2_10_827_t", # current gad year 3+
                         "ksads_10_870_t", # past gad baseline to year 2
                         "ksads_10_869_t", # current gad baseline to year 2
                         "ksads_10_913_t", # gad < min duration baseline to year 2
                         "ksads2_10_873_t", # gad < min duration year 3+
                         "ksads_10_914_t", # past gad < min duration baseline to year 2
                         "ksads2_10_874_t", # past gad < min duration year 3+
                         
                         "ksads_1_840_t", # current mdd baseline to year 2
                         "ksads2_1_790_t", # current mdd year 3+
                         "ksads_1_841_t", # partial remission mdd baseline to year 2
                         "ksads2_1_791_t", # partial remission mdd year 3+
                         "ksads_1_842_t", # past mdd baseline to year 2
                         "ksads2_1_792_t", # past mdd year 3+
                         
                         "ksads_21_922_t", # past ptsd baseline to year 2
                         "ksads2_21_883_t", # past ptsd year 3+
                         "ksads_21_921_t", # current ptsd baseline to year 2
                         "ksads2_21_881_t", # current ptsd year 3+
                         "ksads2_21_882_t" # partial remission ptsd year 3+
                         )) %>%
        left_join(
          select(ksads_p,c("src_subject_id","eventname",
                            "ksads_14_855_p", # partial remission adhd baseline to year 2
                            "ksads_14_854_p", # past adhd baseline to year 2
                            "ksads2_14_810_p", # past adhd year 3+
                            "ksads_14_853_p", # current adhd baseline to year 2
                            "ksads2_14_809_p", # currend adhd year 3+
                            "ksads2_14_812_p", # full remission adhd year 3+ 
                            "ksads2_14_811_p", # partial remission adhd year 3+ 
                            "ksads2_14_813_p", # other adhd year 3+ 
                            "ksads_14_856_p", # unspecified adhd baseline to year 2
                           
                            "ksads2_10_828_p", # past gad year 3+
                            "ksads2_10_827_p", # currend gad year 3+
                            "ksads_10_870_p", # past gad baseline to year 2
                            "ksads_10_869_p", # current gad baseline to year 2
                            "ksads_10_913_p", # gad < min duration baseline to year 2
                            "ksads_10_914_p", # past gad < min duration baseline to year 2
                            "ksads2_10_873_p", # gad < min duration year 3+
                            "ksads2_10_874_p", # past gad < min duration year 3+
                           
                            "ksads_1_841_p", # partial remission mdd baseline to year 2
                            "ksads_1_842_p", # past mdd baseline to year 2
                            "ksads_1_840_p", # current mdd baseline to year 2
                            "ksads2_1_790_p", # current mdd year 3+
                            "ksads2_1_791_p", # partial remission mdd year 3+
                            "ksads2_1_792_p", # past mdd year 3+
                           
                            "ksads_21_922_p", # past ptsd baseline to year 2
                            "ksads2_21_883_p", # past ptsd year 3+
                            "ksads_21_921_p", # current ptsd baseline to year 2
                            "ksads2_21_881_p", # current ptsd year 3+
                            "ksads2_21_882_p" # partial remission ptsd year 3+
                            )),
                  by=c("src_subject_id","eventname")) %>%
              mutate(adhd = case_when(
                                      ksads_14_854_t == 1 ~ 1,
                                      ksads_14_854_t == 0 ~ 0,
                                      ksads_14_854_t == 555 ~ NA,
                                      ksads_14_854_t == 888 ~ NA,
                                      ksads_14_854_t == NA ~ NA,
                                      
                                      ksads2_14_810_t == 1 ~ 1,
                                      ksads2_14_810_t == 0 ~ 0,
                                      ksads2_14_810_t == 555 ~ NA,
                                      ksads2_14_810_t == 888 ~ NA,
                                      ksads2_14_810_t == NA ~ NA,
                                      
                                      ksads_14_853_t == 1 ~ 1,
                                      ksads_14_853_t == 0 ~ 0,
                                      ksads_14_853_t == 555 ~ NA,
                                      ksads_14_853_t == 888 ~ NA,
                                      ksads_14_853_t == NA ~ NA,
                                      
                                      ksads2_14_809_t == 1 ~ 1,
                                      ksads2_14_809_t == 0 ~ 0,
                                      ksads2_14_809_t == 555 ~ NA,
                                      ksads2_14_809_t == 888 ~ NA,
                                      ksads2_14_809_t == NA ~ NA,
                                      
                                      ksads2_14_812_t == 1 ~ 1,
                                      ksads2_14_812_t == 0 ~ 0,
                                      ksads2_14_812_t == 555 ~ NA,
                                      ksads2_14_812_t == 888 ~ NA,
                                      ksads2_14_812_t == NA ~ NA,
                                      
                                      ksads_14_855_t == 1 ~ 1,
                                      ksads_14_855_t == 0 ~ 0,
                                      ksads_14_855_t == 555 ~ NA,
                                      ksads_14_855_t == 888 ~ NA,
                                      ksads_14_855_t == NA ~ NA,
                                      
                                      ksads2_14_811_t == 1 ~ 1,
                                      ksads2_14_811_t == 0 ~ 0,
                                      ksads2_14_811_t == 555 ~ NA,
                                      ksads2_14_811_t == 888 ~ NA,
                                      ksads2_14_811_t == NA ~ NA,
                                    
                                      ksads2_14_813_t == 1 ~ 1,
                                      ksads2_14_813_t == 0 ~ 0,
                                      ksads2_14_813_t == 555 ~ NA,
                                      ksads2_14_813_t == 888 ~ NA,
                                      ksads2_14_813_t == NA ~ NA,
                                      
                                      ksads_14_856_t == 1 ~ 1,
                                      ksads_14_856_t == 0 ~ 0,
                                      ksads_14_856_t == 555 ~ NA,
                                      ksads_14_856_t == 888 ~ NA,
                                      ksads_14_856_t == NA ~ NA,
                                      
                                      ksads_14_855_p == 1 ~ 1,
                                      ksads_14_855_p == 0 ~ 0,
                                      ksads_14_855_p == 555 ~ NA,
                                      ksads_14_855_p == 888 ~ NA,
                                      ksads_14_855_p == NA ~ NA,
                                      
                                      ksads_14_854_p == 1 ~ 1,
                                      ksads_14_854_p == 0 ~ 0,
                                      ksads_14_854_p == 555 ~ NA,
                                      ksads_14_854_p == 888 ~ NA,
                                      ksads_14_854_p == NA ~ NA,
                                      
                                      ksads2_14_810_p == 1 ~ 1,
                                      ksads2_14_810_p == 0 ~ 0,
                                      ksads2_14_810_p == 555 ~ NA,
                                      ksads2_14_810_p == 888 ~ NA,
                                      ksads2_14_810_p == NA ~ NA,
                                      
                                      ksads_14_853_p == 1 ~ 1,
                                      ksads_14_853_p == 0 ~ 0,
                                      ksads_14_853_p == 555 ~ NA,
                                      ksads_14_853_p == 888 ~ NA,
                                      ksads_14_853_p == NA ~ NA,
                                      
                                      ksads2_14_809_p == 1 ~ 1,
                                      ksads2_14_809_p == 0 ~ 0,
                                      ksads2_14_809_p == 555 ~ NA,
                                      ksads2_14_809_p == 888 ~ NA,
                                      ksads2_14_809_p == NA ~ NA,
                                      
                                      ksads2_14_812_p == 1 ~ 1,
                                      ksads2_14_812_p == 0 ~ 0,
                                      ksads2_14_812_p == 555 ~ NA,
                                      ksads2_14_812_p == 888 ~ NA,
                                      ksads2_14_812_p == NA ~ NA,
                                      
                                      ksads2_14_811_p == 1 ~ 1,
                                      ksads2_14_811_p == 0 ~ 0,
                                      ksads2_14_811_p == 555 ~ NA,
                                      ksads2_14_811_p == 888 ~ NA,
                                      ksads2_14_811_p == NA ~ NA,
                                      
                                      ksads2_14_813_p == 1 ~ 1,
                                      ksads2_14_813_p == 0 ~ 0,
                                      ksads2_14_813_p == 555 ~ NA,
                                      ksads2_14_813_p == 888 ~ NA,
                                      ksads2_14_813_p == NA ~ NA,
                                      
                                      ksads_14_856_p == 1 ~ 1,
                                      ksads_14_856_p == 0 ~ 0,
                                      ksads_14_856_p == 555 ~ NA,
                                      ksads_14_856_p == 888 ~ NA,
                                      ksads_14_856_p == NA ~ NA
                                      )) %>%
              mutate(gad = case_when(
                                     ksads2_10_828_t == 1 ~ 1,
                                     ksads2_10_828_t == 0 ~ 0,
                                     ksads2_10_828_t == 555 ~ NA,
                                     ksads2_10_828_t == 888 ~ NA,
                                     ksads2_10_828_t == NA ~ NA,
                                     
                                     ksads2_10_827_t == 1 ~ 1,
                                     ksads2_10_827_t == 0 ~ 0,
                                     ksads2_10_827_t == 555 ~ NA,
                                     ksads2_10_827_t == 888 ~ NA,
                                     ksads2_10_827_t == NA ~ NA,
                                     
                                     ksads_10_870_t == 1 ~ 1,
                                     ksads_10_870_t == 0 ~ 0,
                                     ksads_10_870_t == 555 ~ NA,
                                     ksads_10_870_t == 888 ~ NA,
                                     ksads_10_870_t == NA ~ NA,
                                     
                                     ksads_10_869_t == 1 ~ 1,
                                     ksads_10_869_t == 0 ~ 0,
                                     ksads_10_869_t == 555 ~ NA,
                                     ksads_10_869_t == 888 ~ NA,
                                     ksads_10_869_t == NA ~ NA,
                                     
                                     ksads_10_913_t == 1 ~ 1,
                                     ksads_10_913_t == 0 ~ 0,
                                     ksads_10_913_t == 555 ~ NA,
                                     ksads_10_913_t == 888 ~ NA,
                                     ksads_10_913_t == NA ~ NA,
                                     
                                     ksads2_10_873_t == 1 ~ 1,
                                     ksads2_10_873_t == 0 ~ 0,
                                     ksads2_10_873_t == 555 ~ NA,
                                     ksads2_10_873_t == 888 ~ NA,
                                     ksads2_10_873_t == NA ~ NA,
                                     
                                     ksads_10_914_t == 1 ~ 1,
                                     ksads_10_914_t == 0 ~ 0,
                                     ksads_10_914_t == 555 ~ NA,
                                     ksads_10_914_t == 888 ~ NA,
                                     ksads_10_914_t == NA ~ NA,
                                     
                                     ksads2_10_874_t == 1 ~ 1,
                                     ksads2_10_874_t == 0 ~ 0,
                                     ksads2_10_874_t == 555 ~ NA,
                                     ksads2_10_874_t == 888 ~ NA,
                                     ksads2_10_874_t == NA ~ NA,
                                     
                                     ksads2_10_828_p == 1 ~ 1,
                                     ksads2_10_828_p == 0 ~ 0,
                                     ksads2_10_828_p == 555 ~ NA,
                                     ksads2_10_828_p == 888 ~ NA,
                                     ksads2_10_828_p == NA ~ NA,
                                     
                                     ksads2_10_827_p == 1 ~ 1,
                                     ksads2_10_827_p == 0 ~ 0,
                                     ksads2_10_827_p == 555 ~ NA,
                                     ksads2_10_827_p == 888 ~ NA,
                                     ksads2_10_827_p == NA ~ NA,
                                     
                                     ksads_10_870_p == 1 ~ 1,
                                     ksads_10_870_p == 0 ~ 0,
                                     ksads_10_870_p == 555 ~ NA,
                                     ksads_10_870_p == 888 ~ NA,
                                     ksads_10_870_p == NA ~ NA,
                                     
                                     ksads_10_869_p == 1 ~ 1,
                                     ksads_10_869_p == 0 ~ 0,
                                     ksads_10_869_p == 555 ~ NA,
                                     ksads_10_869_p == 888 ~ NA,
                                     ksads_10_869_p == NA ~ NA,
                                     
                                     ksads_10_913_p == 1 ~ 1,
                                     ksads_10_913_p == 0 ~ 0,
                                     ksads_10_913_p == 555 ~ NA,
                                     ksads_10_913_p == 888 ~ NA,
                                     ksads_10_913_p == NA ~ NA,
                                     
                                     ksads_10_914_p == 1 ~ 1,
                                     ksads_10_914_p == 0 ~ 0,
                                     ksads_10_914_p == 555 ~ NA,
                                     ksads_10_914_p == 888 ~ NA,
                                     ksads_10_914_p == NA ~ NA,
                                     
                                     ksads2_10_873_p == 1 ~ 1,
                                     ksads2_10_873_p == 0 ~ 0,
                                     ksads2_10_873_p == 555 ~ NA,
                                     ksads2_10_873_p == 888 ~ NA,
                                     ksads2_10_873_p == NA ~ NA,
                                     
                                     ksads2_10_874_p == 1 ~ 1,
                                     ksads2_10_874_p == 0 ~ 0,
                                     ksads2_10_874_p == 555 ~ NA,
                                     ksads2_10_874_p == 888 ~ NA,
                                     ksads2_10_874_p == NA ~ NA,
                                     )) %>%
              mutate(mdd = case_when(
                                     ksads_1_840_t == 1 ~ 1,
                                     ksads_1_840_t == 0 ~ 0,
                                     ksads_1_840_t == 555 ~ NA,
                                     ksads_1_840_t == 888 ~ NA,
                                     ksads_1_840_t == NA ~ NA,
                                     
                                     ksads2_1_790_t == 1 ~ 1,
                                     ksads2_1_790_t == 0 ~ 0,
                                     ksads2_1_790_t == 555 ~ NA,
                                     ksads2_1_790_t == 888 ~ NA,
                                     ksads2_1_790_t == NA ~ NA,
                                     
                                     ksads_1_841_t == 1 ~ 1,
                                     ksads_1_841_t == 0 ~ 0,
                                     ksads_1_841_t == 555 ~ NA,
                                     ksads_1_841_t == 888 ~ NA,
                                     ksads_1_841_t == NA ~ NA,
                                     
                                     ksads2_1_791_t == 1 ~ 1,
                                     ksads2_1_791_t == 0 ~ 0,
                                     ksads2_1_791_t == 555 ~ NA,
                                     ksads2_1_791_t == 888 ~ NA,
                                     ksads2_1_791_t == NA ~ NA,
                                     
                                     ksads_1_842_t == 1 ~ 1,
                                     ksads_1_842_t == 0 ~ 0,
                                     ksads_1_842_t == 555 ~ NA,
                                     ksads_1_842_t == 888 ~ NA,
                                     ksads_1_842_t == NA ~ NA,
                                     
                                     ksads2_1_792_t == 1 ~ 1,
                                     ksads2_1_792_t == 0 ~ 0,
                                     ksads2_1_792_t == 555 ~ NA,
                                     ksads2_1_792_t == 888 ~ NA,
                                     ksads2_1_792_t == NA ~ NA,
                                     
                                     ksads_1_841_p == 1 ~ 1,
                                     ksads_1_841_p == 0 ~ 0,
                                     ksads_1_841_p == 555 ~ NA,
                                     ksads_1_841_p == 888 ~ NA,
                                     ksads_1_841_p == NA ~ NA,
                                     
                                     ksads_1_842_p == 1 ~ 1,
                                     ksads_1_842_p == 0 ~ 0,
                                     ksads_1_842_p == 555 ~ NA,
                                     ksads_1_842_p == 888 ~ NA,
                                     ksads_1_842_p == NA ~ NA,
                                     
                                     ksads_1_840_p == 1 ~ 1,
                                     ksads_1_840_p == 0 ~ 0,
                                     ksads_1_840_p == 555 ~ NA,
                                     ksads_1_840_p == 888 ~ NA,
                                     ksads_1_840_p == NA ~ NA,
                                     
                                     ksads2_1_790_p == 1 ~ 1,
                                     ksads2_1_790_p == 0 ~ 0,
                                     ksads2_1_790_p == 555 ~ NA,
                                     ksads2_1_790_p == 888 ~ NA,
                                     ksads2_1_790_p == NA ~ NA,
                                     
                                     ksads2_1_791_p == 1 ~ 1,
                                     ksads2_1_791_p == 0 ~ 0,
                                     ksads2_1_791_p == 555 ~ NA,
                                     ksads2_1_791_p == 888 ~ NA,
                                     ksads2_1_791_p == NA ~ NA,
                                     
                                     ksads2_1_792_p == 1 ~ 1,
                                     ksads2_1_792_p == 0 ~ 0,
                                     ksads2_1_792_p == 555 ~ NA,
                                     ksads2_1_792_p == 888 ~ NA,
                                     ksads2_1_792_p == NA ~ NA
                                     )) %>%
              mutate(ptsd = case_when(
                                      ksads_21_922_t == 1 ~ 1,
                                      ksads_21_922_t == 0 ~ 0,
                                      ksads_21_922_t == 555 ~ NA,
                                      ksads_21_922_t == 888 ~ NA,
                                      ksads_21_922_t == NA ~ NA,
                                      
                                      ksads2_21_883_t == 1 ~ 1,
                                      ksads2_21_883_t == 0 ~ 0,
                                      ksads2_21_883_t == 555 ~ NA,
                                      ksads2_21_883_t == 888 ~ NA,
                                      ksads2_21_883_t == NA ~ NA,
                                      
                                      ksads_21_921_t == 1 ~ 1,
                                      ksads_21_921_t == 0 ~ 0,
                                      ksads_21_921_t == 555 ~ NA,
                                      ksads_21_921_t == 888 ~ NA,
                                      ksads_21_921_t == NA ~ NA,
                                      
                                      ksads2_21_881_t == 1 ~ 1,
                                      ksads2_21_881_t == 0 ~ 0,
                                      ksads2_21_881_t == 555 ~ NA,
                                      ksads2_21_881_t == 888 ~ NA,
                                      ksads2_21_881_t == NA ~ NA,
                                      
                                      ksads2_21_882_t == 1 ~ 1,
                                      ksads2_21_882_t == 0 ~ 0,
                                      ksads2_21_882_t == 555 ~ NA,
                                      ksads2_21_882_t == 888 ~ NA,
                                      ksads2_21_882_t == NA ~ NA,
                                      
                                      ksads_21_922_p == 1 ~ 1,
                                      ksads_21_922_p == 0 ~ 0,
                                      ksads_21_922_p == 555 ~ NA,
                                      ksads_21_922_p == 888 ~ NA,
                                      ksads_21_922_p == NA ~ NA,
                                      
                                      ksads2_21_883_p == 1 ~ 1,
                                      ksads2_21_883_p == 0 ~ 0,
                                      ksads2_21_883_p == 555 ~ NA,
                                      ksads2_21_883_p == 888 ~ NA,
                                      ksads2_21_883_p == NA ~ NA,
                                      
                                      ksads_21_921_p == 1 ~ 1,
                                      ksads_21_921_p == 0 ~ 0,
                                      ksads_21_921_p == 555 ~ NA,
                                      ksads_21_921_p == 888 ~ NA,
                                      ksads_21_921_p == NA ~ NA,
                                      
                                      ksads2_21_881_p == 1 ~ 1,
                                      ksads2_21_881_p == 0 ~ 0,
                                      ksads2_21_881_p == 555 ~ NA,
                                      ksads2_21_881_p == 888 ~ NA,
                                      ksads2_21_881_p == NA ~ NA,
                                      
                                      ksads2_21_882_p == 1 ~ 1,
                                      ksads2_21_882_p == 0 ~ 0,
                                      ksads2_21_882_p == 555 ~ NA,
                                      ksads2_21_882_p == 888 ~ NA,
                                      ksads2_21_882_p == NA ~ NA
                                      )) %>%
              select(c("src_subject_id","eventname",
                       "adhd","gad","mdd","ptsd"))








### calculate income to needs ratio
income_df <- demo %>%
              select(c("src_subject_id","eventname",
                       "demo_roster_v2","demo_roster_v2_l",
                       "demo_roster_v2_refuse","demo_roster_v2_refuse_l",
                       "demo_comb_income_v2","demo_comb_income_v2_l")) %>%
              # combine items for income from baseline to yr 2 and yr 3+
              mutate(income_category = case_when(!is.na(demo_comb_income_v2) ~ demo_comb_income_v2,
                                        !is.na(demo_comb_income_v2_l) ~ demo_comb_income_v2_l
                                  )) %>%
              # for income replace 777 and 999 with NA
              mutate(income_category = ifelse(income_category %in% 
                                                c(777,999) , NA, income_category)) %>%
              # add column for middle value of income category (or upper for 10)
              mutate(income_val = case_when(income_category == 1 ~ 2499.5, # less than 5,000
                                            income_category == 2 ~ 8499.5, # 5,000 to 11,999
                                            income_category == 3 ~ 13999.5, # 12,000 to 15,999
                                            income_category == 4 ~ 20499.5, # 16,000 to 24,999
                                            income_category == 5 ~ 29999.5, # 25,000 to 34,999
                                            income_category == 6 ~ 42499.5, # 35,000 to 49,999
                                            income_category == 7 ~ 62499.5, # 50,000 to 74,999
                                            income_category == 8 ~ 87499.5, # 75,000 to 99,999
                                            income_category == 9 ~ 149999.5, # 100,000 to 199,999
                                            income_category == 10 ~ 200000 # 200,000 and greater
                                  )) %>%
              # combine items for household size from baseline to yr 2 and yr 3+
              mutate(household_size = case_when(demo_roster_v2_refuse %in% c(777,999) ~ NA,
                                                demo_roster_v2_refuse_l %in% c(777,999) ~ NA,
                                        !is.na(demo_roster_v2) ~ demo_roster_v2,
                                        !is.na(demo_roster_v2_l) ~ demo_roster_v2_l
                                  )) %>%
              # for household size replace unreasonable values with NA
              mutate(household_size = ifelse(household_size %in% 
                                                c(-4, 0, 41, 43, 56, 60, 77, 110, 2300) , NA, household_size)) %>%
              # add year data was collected
              left_join(select(meta,c("src_subject_id","eventname","interview_date")),
                                    by=c("src_subject_id","eventname")) %>%
              mutate(year = as.integer(gsub("^.{1,6}","",interview_date))) %>%
              # add federal poverty line for given year and household size
              left_join(poverty_info,by=c("household_size","year")) %>%
              # calculate income to needs ratio
              mutate(income_to_needs = income_val/poverty_line)


## group all abcd data ####  
abcd_all <- demo %>%
              select(c("src_subject_id","eventname","demo_sex_v2",
                       "demo_gender_id_v2","demo_gender_id_v2_l")) %>%
              # to copy sex (asked only at baseline) to other years
              group_by(src_subject_id) %>%
              mutate(sex = first(demo_sex_v2)) %>%
              ungroup() %>%
              # only 12 subjects are intersex which is too small to analyze
              # so set to NA
              mutate(sex = if_else(sex==3,NA,sex)) %>%
              # combine items for gender from baseline to yr 2 and yr 3+
              mutate(gender_id = case_when(!is.na(demo_gender_id_v2) ~ demo_gender_id_v2,
                                        !is.na(demo_gender_id_v2_l) ~ demo_gender_id_v2_l
                                  )) %>%
              # for gender replace 777 and 999 with NA
              mutate(gender_id = ifelse(gender_id %in% c(777,999) , NA, gender_id)) %>%
              # add income to needs ratio
              left_join(income_df,by=c("src_subject_id","eventname")) %>%
              # add site and interview age
              left_join(select(meta,
                               c("src_subject_id","eventname",
                                 "site_id_l","interview_age")),
                        by=c("src_subject_id","eventname")) %>%
              rename(site = site_id_l) %>%
              # add cbcl scores
              left_join(select(cbcl,
                               c("src_subject_id","eventname",
                                 "cbcl_scr_syn_aggressive_t","cbcl_scr_syn_attention_t",
                                 "cbcl_scr_syn_anxdep_t","cbcl_scr_syn_external_t",
                                 "cbcl_scr_syn_internal_t","cbcl_scr_syn_rulebreak_t",
                                 "cbcl_scr_syn_social_t","cbcl_scr_syn_somatic_t",
                                 "cbcl_scr_syn_thought_t","cbcl_scr_syn_totprob_t",
                                 "cbcl_scr_syn_withdep_t")),
                        by=c("src_subject_id","eventname")) %>%
              # add current ksads scores
              left_join(ksads,by=c("src_subject_id","eventname")) %>%
              # add lifetime ksads scores
              left_join(select(ksads_lifetime,
                               c("src_subject_id","eventname",
                                 "lifetime_adhd","umbrella_anxiety_disorder",
                                 "lifetime_mdd","lifetime_ptsd")))

## group all prs data ####
prs_all <- prs_all_mhc %>%
              left_join(select(prs_one_mhc,c("SCORESUM","IID")),
                        by="IID") %>%
              rename(prs_all_mhc_val = SCORESUM.x,
                     prs_one_mhc_val = SCORESUM.y) %>%
              left_join(select(prs_no_mhc,c("SCORESUM","IID")),
                        by="IID") %>%
              rename(prs_no_mhc_val = SCORESUM) %>%
              select(c("IID","prs_all_mhc_val","prs_one_mhc_val","prs_no_mhc_val")) %>%
              rename(src_subject_id = IID)
prs_all$src_subject_id <- gsub("^.{1,10}","",prs_all$src_subject_id) #if remove first 10 char then = subject id as in abcd

## make categorical ancestry groups ####
afr_gp <- afr_gp %>% mutate(ancestry="Afr")
amadmix_gp <- amadmix_gp %>% mutate(ancestry="AmAdmix")
eur_gp <- eur_gp %>% mutate(ancestry="Eur")
ancestry_gp_all <- bind_rows(afr_gp,amadmix_gp,eur_gp) %>%
                      select("subjectkey","ancestry","V1","V2","V3","V4","V5","V6","V7","V8") %>%
                      rename(src_subject_id = subjectkey)

# rename grms so names are consistent with abcd names
#if remove first 10 char from rownames in grm then = subject id
rownames(all_grm) <- gsub("^.{1,10}","",rownames(all_grm)) 
colnames(all_grm) <- gsub("^.{1,10}","",colnames(all_grm))
rownames(afr_grm) <- gsub("^.{1,10}","",rownames(afr_grm))
colnames(afr_grm) <- gsub("^.{1,10}","",colnames(afr_grm))
rownames(amadmix_grm) <- gsub("^.{1,10}","",rownames(amadmix_grm))
colnames(amadmix_grm) <- gsub("^.{1,10}","",colnames(amadmix_grm))
rownames(eur_grm) <- gsub("^.{1,10}","",rownames(eur_grm))
colnames(eur_grm) <- gsub("^.{1,10}","",colnames(eur_grm))

### combine all data except grms ####
data_all <- abcd_all %>%
              left_join(prs_all, by="src_subject_id") %>%
              left_join(ancestry_gp_all, by="src_subject_id")

### remove subjects without ancestry information ####
data_all <- data_all %>% filter(!is.na(ancestry))

### Z-score all PRS based on ancestry ####
data_all <- data_all %>% 
          group_by(ancestry) %>%
          mutate(Zprs_all_mhc_val = as.numeric(scale(prs_all_mhc_val, scale=TRUE))) %>%
          mutate(Zprs_one_mhc_val = as.numeric(scale(prs_one_mhc_val, scale=TRUE))) %>%
          mutate(Zprs_no_mhc_val = as.numeric(scale(prs_no_mhc_val, scale=TRUE)))

```

### Separate data based on collection date

``` {separate data based on collection date, r}

baseline_data <- data_all %>% filter(eventname == "baseline_year_1_arm_1")
yr1_data <- data_all %>% filter(eventname == "1_year_follow_up_y_arm_1")
yr2_data <- data_all %>% filter(eventname == "2_year_follow_up_y_arm_1")
yr3_data <- data_all %>% filter(eventname == "3_year_follow_up_y_arm_1")
yr4_data <- data_all %>% filter(eventname == "4_year_follow_up_y_arm_1")

```

### Reorder data so matches grm

```{reorder data so matches grm, r}

### All ancestries ####
all_grm_for_yr <- all_grm[which(rownames(all_grm) %in% yr4_data$src_subject_id),]
all_grm_for_yr <- all_grm_for_yr[,which(colnames(all_grm_for_yr) %in% yr4_data$src_subject_id)]
row_indices_All <- match(yr4_data$src_subject_id,rownames(all_grm_for_yr)) 
all_grm_sparse_subsetted <- all_grm_for_yr[row_indices_All, row_indices_All]
all_yr4_data_reordered <- yr4_data[match(colnames(all_grm_sparse_subsetted),yr4_data$src_subject_id),]
all_yr4_data_reordered <- all_yr4_data_reordered %>% column_to_rownames(var="src_subject_id")

### African ancestry ####
afr_grm_for_yr <- afr_grm[which(rownames(afr_grm) %in% yr4_data$src_subject_id),]
afr_grm_for_yr <- afr_grm_for_yr[,which(colnames(afr_grm_for_yr) %in% yr4_data$src_subject_id)]
row_indices_All <- match(yr4_data$src_subject_id,rownames(afr_grm_for_yr)) 
afr_yr4_data <- yr4_data %>% filter(ancestry=="Afr")
row_indices_All <- match(afr_yr4_data$src_subject_id,rownames(afr_grm_for_yr))
afr_grm_sparse_subsetted <- afr_grm_for_yr[row_indices_All, row_indices_All]
afr_yr4_data_reordered <- afr_yr4_data[match(colnames(afr_grm_sparse_subsetted),
                                                       afr_yr4_data$src_subject_id),]
afr_yr4_data_reordered <- afr_yr4_data_reordered %>% column_to_rownames(var="src_subject_id")

### American admixed ancestry ####
amadmix_for_yr <- amadmix_grm[which(rownames(amadmix_grm) %in% yr4_data$src_subject_id),]
amadmix_for_yr <- amadmix_for_yr[,which(colnames(amadmix_for_yr) %in% yr4_data$src_subject_id)]
row_indices_All <- match(yr4_data$src_subject_id,rownames(amadmix_for_yr)) 
amadmix_yr4_data <- yr4_data %>% filter(ancestry=="AmAdmix")
row_indices_All <- match(amadmix_yr4_data$src_subject_id,rownames(amadmix_for_yr))
amadmix_grm_sparse_subsetted <- amadmix_for_yr[row_indices_All, row_indices_All]
amadmix_yr4_data_reordered <- amadmix_yr4_data[match(colnames(amadmix_grm_sparse_subsetted),
                                                               amadmix_yr4_data$src_subject_id),]
amadmix_yr4_data_reordered <- amadmix_yr4_data_reordered %>% column_to_rownames(var="src_subject_id")


### European ancestry ####
eur_grm_for_yr <- eur_grm[which(rownames(eur_grm) %in% yr4_data$src_subject_id),]
eur_grm_for_yr <- eur_grm_for_yr[,which(colnames(eur_grm_for_yr) %in% yr4_data$src_subject_id)]
eur_yr4_data <- yr4_data %>% filter(ancestry=="Eur")
row_indices_All <- match(eur_yr4_data$src_subject_id,rownames(eur_grm_for_yr))
eur_grm_sparse_subsetted <- eur_grm_for_yr[row_indices_All, row_indices_All]
eur_yr4_data_reordered <- eur_yr4_data[match(colnames(eur_grm_sparse_subsetted),
                                                       eur_yr4_data$src_subject_id),]
eur_yr4_data_reordered <- eur_yr4_data_reordered %>% column_to_rownames(var="src_subject_id")

```

### Run grm and all ancestry pc for all CBCL outcomes at yr4

``` {run grm and all ancestry pc for all cbcl outcomes, r}

## run lin reg for each cbcl outcome ####
cbcl_outcome_list <- c("cbcl_scr_syn_aggressive_t","cbcl_scr_syn_attention_t",
                  "cbcl_scr_syn_anxdep_t","cbcl_scr_syn_external_t",
                  "cbcl_scr_syn_internal_t","cbcl_scr_syn_rulebreak_t",
                  "cbcl_scr_syn_social_t","cbcl_scr_syn_somatic_t",
                  "cbcl_scr_syn_thought_t","cbcl_scr_syn_totprob_t",
                  "cbcl_scr_syn_withdep_t" )

lm_resid_cbcl_list <- list() 
for (outcome in cbcl_outcome_list) {
  lm_model <- fitNullModel(all_yr4_data_reordered, 
                           outcome = outcome, 
                           covars = c(paste0("V", 1:8)), 
                           cov.mat = all_grm_sparse_subsetted, 
                           verbose = TRUE)
  lm_resid_cbcl_list[[outcome]] <- lm_model$fit %>%
                              rownames_to_column("id") %>%
                              select(c(id,resid.conditional))
}

## make one data frame with residuals for all cbcl results
lm_all_cond_resid_cbcl_long <- imap_dfr(lm_resid_cbcl_list, ~mutate(.x, .id = .y))
lm_resid_cbcl <- lm_all_cond_resid_cbcl_long %>%
  pivot_wider(names_from = .id, values_from = resid.conditional)

```

### Run grm and all ancestry pc regressions for KSADS outcomes at yr4

```{run grm and all ancestry pc for all ksads outcomes, r}

## run lin reg for each ksads outcome ####

ksads_outcome_list <- c("adhd","gad","mdd","ptsd")

lm_resid_ksads_list <- list() # initialize a list to store results  
for (outcome in ksads_outcome_list) {
  lm_model <- fitNullModel(all_yr4_data_reordered, 
                           outcome = outcome, 
                           covars = c(paste0("V", 1:8)), 
                           cov.mat = all_grm_sparse_subsetted, 
                           verbose = TRUE,
                           family = "binomial")
  lm_resid_ksads_list[[outcome]] <- lm_model$fit %>%
                              rownames_to_column("id") %>%
                              select(c(id,resid.conditional))
}

## make one data frame with residuals for all ksads results
lm_all_cond_resid_ksads_long <- imap_dfr(lm_resid_ksads_list, ~mutate(.x, .id = .y))
lm_resid_ksads <- lm_all_cond_resid_ksads_long %>%
  pivot_wider(names_from = .id, values_from = resid.conditional)

```

### Run grm and eur ancestry pc for all CBCL outcomes at yr4

``` {run grm and eur ancestry pc for all cbcl outcomes, r}

## run lin reg for each cbcl outcome ####
cbcl_outcome_list <- c("cbcl_scr_syn_aggressive_t","cbcl_scr_syn_attention_t",
                  "cbcl_scr_syn_anxdep_t","cbcl_scr_syn_external_t",
                  "cbcl_scr_syn_internal_t","cbcl_scr_syn_rulebreak_t",
                  "cbcl_scr_syn_social_t","cbcl_scr_syn_somatic_t",
                  "cbcl_scr_syn_thought_t","cbcl_scr_syn_totprob_t",
                  "cbcl_scr_syn_withdep_t" )

lm_resid_cbcl_list <- list() 
for (outcome in cbcl_outcome_list) {
  lm_model <- fitNullModel(eur_yr4_data_reordered, 
                           outcome = outcome, 
                           covars = c(paste0("V", 1:8)), 
                           cov.mat = eur_grm_sparse_subsetted, 
                           verbose = TRUE)
  lm_resid_cbcl_list[[outcome]] <- lm_model$fit %>%
                              rownames_to_column("id") %>%
                              select(c(id,resid.conditional))
}

## make one data frame with residuals for all cbcl results
lm_eur_cond_resid_cbcl_long <- imap_dfr(lm_resid_cbcl_list, ~mutate(.x, .id = .y))
lm_resid_cbcl <- lm_eur_cond_resid_cbcl_long %>%
  pivot_wider(names_from = .id, values_from = resid.conditional)

```

### Run grm and eur ancestry pc regressions for KSADS outcomes at yr4

```{run grm and eur ancestry pc for all ksads outcomes, r}

## run lin reg for each ksads outcome ####

# ksads_outcome_list <- c("adhd","gad","mdd","ptsd")
ksads_outcome_list <- c("lifetime_adhd","umbrella_anxiety_disorder",
                        "lifetime_mdd","lifetime_ptsd")


lm_resid_ksads_list <- list() # initialize a list to store results  
for (outcome in ksads_outcome_list) {
  lm_model <- fitNullModel(eur_yr4_data_reordered, 
                           outcome = outcome, 
                           covars = c(paste0("V", 1:8)), 
                           cov.mat = eur_grm_sparse_subsetted, 
                           verbose = TRUE,
                           family = "binomial")
  lm_resid_ksads_list[[outcome]] <- lm_model$fit %>%
                              rownames_to_column("id") %>%
                              select(c(id,resid.conditional))
}

## make one data frame with residuals for all ksads results
lm_eur_cond_resid_ksads_long <- imap_dfr(lm_resid_ksads_list, ~mutate(.x, .id = .y))
lm_resid_ksads <- lm_eur_cond_resid_ksads_long %>%
  pivot_wider(names_from = .id, values_from = resid.conditional)

```

### Run grm and afr ancestry pc for all CBCL outcomes at yr4

``` {run grm and afr ancestry pc for all cbcl outcomes, r}

## run lin reg for each cbcl outcome ####
cbcl_outcome_list <- c("cbcl_scr_syn_aggressive_t","cbcl_scr_syn_attention_t",
                  "cbcl_scr_syn_anxdep_t","cbcl_scr_syn_external_t",
                  "cbcl_scr_syn_internal_t","cbcl_scr_syn_rulebreak_t",
                  "cbcl_scr_syn_social_t","cbcl_scr_syn_somatic_t",
                  "cbcl_scr_syn_thought_t","cbcl_scr_syn_totprob_t",
                  "cbcl_scr_syn_withdep_t" )

lm_resid_cbcl_list <- list() 
for (outcome in cbcl_outcome_list) {
  lm_model <- fitNullModel(afr_yr4_data_reordered, 
                           outcome = outcome, 
                           covars = c(paste0("V", 1:8)), 
                           cov.mat = afr_grm_sparse_subsetted, 
                           verbose = TRUE)
  lm_resid_cbcl_list[[outcome]] <- lm_model$fit %>%
                              rownames_to_column("id") %>%
                              select(c(id,resid.conditional))
}

## make one data frame with residuals for all cbcl results
lm_afr_cond_resid_cbcl_long <- imap_dfr(lm_resid_cbcl_list, ~mutate(.x, .id = .y))
lm_resid_cbcl <- lm_afr_cond_resid_cbcl_long %>%
  pivot_wider(names_from = .id, values_from = resid.conditional)

```

### Run grm and afr ancestry pc regressions for KSADS outcomes at yr4

```{run grm and afr ancestry pc for all ksads outcomes, r}

## run lin reg for each ksads outcome ####

# ksads_outcome_list <- c("adhd","gad","mdd","ptsd")
## note: too few adhd subjects to run
ksads_outcome_list <- c("gad","mdd","ptsd")

lm_resid_ksads_list <- list() # initialize a list to store results  
for (outcome in ksads_outcome_list) {
  lm_model <- fitNullModel(afr_yr4_data_reordered, 
                           outcome = outcome, 
                           covars = c(paste0("V", 1:8)), 
                           cov.mat = afr_grm_sparse_subsetted, 
                           verbose = TRUE,
                           family = "binomial")
  lm_resid_ksads_list[[outcome]] <- lm_model$fit %>%
                              rownames_to_column("id") %>%
                              select(c(id,resid.conditional))
}

## make one data frame with residuals for all ksads results
lm_afr_cond_resid_ksads_long <- imap_dfr(lm_resid_ksads_list, ~mutate(.x, .id = .y))
lm_resid_ksads <- lm_afr_cond_resid_ksads_long %>%
  pivot_wider(names_from = .id, values_from = resid.conditional)

```

### Run grm and am admix ancestry pc for all CBCL outcomes at yr4

``` {run grm and am admix ancestry pc for all cbcl outcomes, r}

## run lin reg for each cbcl outcome ####
cbcl_outcome_list <- c("cbcl_scr_syn_aggressive_t","cbcl_scr_syn_attention_t",
                  "cbcl_scr_syn_anxdep_t","cbcl_scr_syn_external_t",
                  "cbcl_scr_syn_internal_t","cbcl_scr_syn_rulebreak_t",
                  "cbcl_scr_syn_social_t","cbcl_scr_syn_somatic_t",
                  "cbcl_scr_syn_thought_t","cbcl_scr_syn_totprob_t",
                  "cbcl_scr_syn_withdep_t" )

lm_resid_cbcl_list <- list() 
for (outcome in cbcl_outcome_list) {
  lm_model <- fitNullModel(amadmix_yr4_data_reordered, 
                           outcome = outcome, 
                           covars = c(paste0("V", 1:8)), 
                           cov.mat = amadmix_grm_sparse_subsetted, 
                           verbose = TRUE)
  lm_resid_cbcl_list[[outcome]] <- lm_model$fit %>%
                              rownames_to_column("id") %>%
                              select(c(id,resid.conditional))
}

## make one data frame with residuals for all cbcl results
lm_amadmix_cond_resid_cbcl_long <- imap_dfr(lm_resid_cbcl_list, ~mutate(.x, .id = .y))
lm_resid_cbcl <- lm_amadmix_cond_resid_cbcl_long %>%
  pivot_wider(names_from = .id, values_from = resid.conditional)

```

### Run grm and am admix ancestry pc regressions for KSADS outcomes at yr4

```{run grm and am admix ancestry pc for all ksads outcomes, r}

## run lin reg for each ksads outcome ####

# ksads_outcome_list <- c("adhd","gad","mdd","ptsd")
## note: too few adhd subjects to run
ksads_outcome_list <- c("gad","mdd","ptsd")

lm_resid_ksads_list <- list() # initialize a list to store results  
for (outcome in ksads_outcome_list) {
  lm_model <- fitNullModel(amadmix_yr4_data_reordered, 
                           outcome = outcome, 
                           covars = c(paste0("V", 1:8)), 
                           cov.mat = amadmix_grm_sparse_subsetted, 
                           verbose = TRUE,
                           family = "binomial")
  lm_resid_ksads_list[[outcome]] <- lm_model$fit %>%
                              rownames_to_column("id") %>%
                              select(c(id,resid.conditional))
}

## make one data frame with residuals for all ksads results
lm_amadmix_cond_resid_ksads_long <- imap_dfr(lm_resid_ksads_list, ~mutate(.x, .id = .y))
lm_resid_ksads <- lm_amadmix_cond_resid_ksads_long %>%
  pivot_wider(names_from = .id, values_from = resid.conditional)

```

### Run regression for CBCL outcomes ~ PRS + covariates at yr4

``` {subset data for regression, r}

## subset data for regression, combine with residuals from last regression ####
yr4_reg_data <- yr4_data %>%
                select(c("src_subject_id","prs_all_mhc_val",
                         "demo_gender_id_v2_l",
                         "sex",
                         "income_to_needs","site","interview_age",
                         "ancestry",
                         "cbcl_scr_syn_aggressive_t","cbcl_scr_syn_attention_t",
                         "cbcl_scr_syn_anxdep_t","cbcl_scr_syn_external_t",
                         "cbcl_scr_syn_internal_t","cbcl_scr_syn_rulebreak_t",
                         "cbcl_scr_syn_social_t","cbcl_scr_syn_somatic_t",
                         "cbcl_scr_syn_thought_t","cbcl_scr_syn_totprob_t",
                         "cbcl_scr_syn_withdep_t",
                         # "adhd", #only 1 afr, 2 amadmix, 6 eur cases so do not analyze
                         # "gad","mdd","ptsd",
                         "lifetime_adhd","umbrella_anxiety_disorder",
                         "lifetime_mdd","lifetime_ptsd"
                         )) %>%
                rename(
                  id = src_subject_id,
                  gender = demo_gender_id_v2_l,
                  age = interview_age,
                  prs = prs_all_mhc_val,
                  raw_c_aggress = cbcl_scr_syn_aggressive_t,
                  raw_c_attn = cbcl_scr_syn_attention_t,
                  raw_c_anxdep = cbcl_scr_syn_anxdep_t,
                  raw_c_ext = cbcl_scr_syn_external_t,
                  raw_c_int = cbcl_scr_syn_internal_t,
                  raw_c_rule = cbcl_scr_syn_rulebreak_t,
                  raw_c_social = cbcl_scr_syn_social_t,
                  raw_c_somatic = cbcl_scr_syn_somatic_t,
                  raw_c_thought = cbcl_scr_syn_thought_t,
                  raw_c_total = cbcl_scr_syn_totprob_t,
                  raw_c_withdep = cbcl_scr_syn_withdep_t,
                  # raw_k_adhd = adhd, #only 1 afr, 2 amadmix, 6 eur cases so do not analyze
                  # raw_k_gad = gad,
                  # raw_k_mdd = mdd,
                  # raw_k_ptsd = ptsd
                  raw_k_life_adhd = lifetime_adhd,
                  raw_k_life_anx = umbrella_anxiety_disorder,
                  raw_k_life_mdd = lifetime_mdd,
                  raw_k_life_ptsd = lifetime_ptsd
                ) %>%

                  mutate(gender = case_when(gender == 1 ~ "cism",
                                          gender == 2 ~ "cisf",
                                          gender == 3 ~ "gnc", #trans m
                                          gender == 4 ~ "gnc", #trans f
                                          gender == 5 ~ "gnc", #genderqueer
                                          gender == 6 ~ "gnc", #other
                                          gender == 777 ~ NA,
                                          gender == 999 ~ NA,
                )) %>%
                                          
                #remove subjects without sex info
                filter(sex != is.na(sex)) %>%

                #remove subjects without gender info
                filter(gender != is.na(gender)) %>%
    
                #remove subjects without income info
                filter(income_to_needs != is.na(income_to_needs)) %>%

                left_join(lm_resid_cbcl,by="id") %>%
                left_join(lm_resid_ksads,by="id") %>%
                rename(
                        res_c_aggress = cbcl_scr_syn_aggressive_t,
                        res_c_attn = cbcl_scr_syn_attention_t,
                        res_c_anxdep = cbcl_scr_syn_anxdep_t,
                        res_c_ext = cbcl_scr_syn_external_t,
                        res_c_int = cbcl_scr_syn_internal_t,
                        res_c_rule = cbcl_scr_syn_rulebreak_t,
                        res_c_social = cbcl_scr_syn_social_t,
                        res_c_somatic = cbcl_scr_syn_somatic_t,
                        res_c_thought = cbcl_scr_syn_thought_t,
                        res_c_total = cbcl_scr_syn_totprob_t,
                        res_c_withdep = cbcl_scr_syn_withdep_t,
                        # res_k_adhd = adhd, #only 1 afr, 2 amadmix, 6 eur cases so do not analyze
                        # res_k_gad = gad,
                        # res_k_mdd = mdd,
                        # res_k_ptsd = ptsd
                        res_k_life_adhd = lifetime_adhd,
                        res_k_life_anx = umbrella_anxiety_disorder,
                        res_k_life_mdd = lifetime_mdd,
                        res_k_life_ptsd = lifetime_ptsd
                ) %>%
        
### dummy code, effect code, and cluster mean center categorical variables ####
## dummy
# sex - male = 0, female = 1
# gender - cismale: gen_dum_cisf = 0, gen_dum_gnc = 0
# gender - cisfemale: gen_dum_cisf = 1, gen_dum_gnc = 0
# gender - gnc/other: gen_dum_cisf = 0, gen_dum_gnc = 1
# ancestry - amadmix: anc_dum_afr = 0, anc_dum_eur = 0
# ancestry - afr: anc_dum_afr = 1, anc_dum_eur = 0
# ancestry - eur: anc_dum_afr = 0, anc_dum_eur = 1
## effect
# sex - male = -1, female = 1
# gender - cismale: gen_eff_cisf = -1, gen_eff_gnc = -1
# gender - cisfemale: gen_eff_cisf = 1, gen_eff_gnc = 0
# gender - gnc/other: gen_eff_cisf = 0, gen_eff_gnc = 1
# ancestry - amadmix: anc_eff_afr = -1, anc_eff_eur = -1
# ancestry - afr: anc_eff_afr = 1, anc_eff_eur = 0
# ancestry - eur: anc_eff_afr = 0, anc_eff_eur = 1

                # dummy coding
                mutate(sex_dum_cisf = case_when(sex == 1 ~ 0,
                                                sex == 2 ~ 1)) %>%
                mutate(gen_dum_cisf = case_when(gender == "cism" ~ 0,
                                                gender == "cisf" ~ 1,
                                                gender == "gnc" ~ 0)) %>%
                mutate(gen_dum_gnc = case_when(gender == "cism" ~ 0,
                                                gender == "cisf" ~ 0,
                                                gender == "gnc" ~ 1)) %>%
                mutate(anc_dum_afr = case_when(ancestry == "AmAdmix" ~ 0,
                                               ancestry == "Afr" ~ 1,
                                               ancestry == "Eur" ~ 0)) %>%
                mutate(anc_dum_eur = case_when(ancestry == "AmAdmix" ~ 0,
                                               ancestry == "Afr" ~ 0,
                                               ancestry == "Eur" ~ 1)) %>%
                # effect coding
                mutate(sex_eff_cisf = case_when(sex == 1 ~ -1,
                                                sex == 2 ~ 1)) %>%
                mutate(gen_eff_cisf = case_when(gender == "cism" ~ -1,
                                                gender == "cisf" ~ 1,
                                                gender == "gnc" ~ 0)) %>%
                mutate(gen_eff_gnc = case_when(gender == "cism" ~ -1,
                                                gender == "cisf" ~ 0,
                                                gender == "gnc" ~ 1)) %>%
                # mutate(anc_eff_afr = as.numeric(car::recode(anc_dum_afr, "0=-1;1=1"))) %>%
                mutate(anc_eff_afr = case_when(ancestry == "AmAdmix" ~ -1,
                                               ancestry == "Afr" ~ 1,
                                               ancestry == "Eur" ~ 0)) %>%
                mutate(anc_eff_eur = case_when(ancestry == "AmAdmix" ~ -1,
                                               ancestry == "Afr" ~ 0,
                                               ancestry == "Eur" ~ 1)) %>%
                # cluster mean center categorical predictors
                mutate(sex_cmc_cisf = as.numeric(center(sex_eff_cisf, 
                                     type="CWC", cluster = site))) %>%
                mutate(gen_cmc_cisf = as.numeric(center(gen_eff_cisf, 
                                     type="CWC", cluster = site))) %>%
                mutate(gen_cmc_gnc = as.numeric(center(gen_eff_gnc, 
                                     type="CWC", cluster = site))) %>%
                mutate(anc_cmc_afr = as.numeric(center(anc_eff_afr,
                                     type="CWC", cluster = site))) %>%
                mutate(anc_cmc_eur = as.numeric(center(anc_eff_eur,
                                     type="CWC", cluster = site))) %>%
                # cluster mean center continuous predictors
                mutate(cmc_prs = as.numeric(center(prs,type="CWC",cluster=site))) %>%
                mutate(cmc_age = as.numeric(center(age,type="CWC",cluster=site))) %>%
                mutate(cmc_income_to_needs = as.numeric(center(income_to_needs,
                                                        type="CWC",cluster=site))) %>%
                # Z score continuous predictors ()
                mutate(zcmc_prs = cmc_prs) %>%
                mutate(zcmc_age = as.numeric(scale(cmc_age, scale=TRUE))) %>%
                mutate(zcmc_income = as.numeric(scale(cmc_income_to_needs, scale=TRUE))) %>%

                # remove subjects without cbcl data
                filter(!is.na(res_c_total)) %>%

                # remove subjects without ksads data
                # filter(!is.na(res_k_ptsd)) %>%
                filter(!is.na(raw_k_life_ptsd)) %>%

                #reorder columns so easier to work with
                select(id,site,prs,age,income_to_needs,gender,sex,ancestry,
                       zcmc_prs,zcmc_age,zcmc_income,
                       sex_dum_cisf, sex_eff_cisf, sex_cmc_cisf,
                       gen_dum_cisf,gen_dum_gnc,
                       gen_eff_cisf,gen_eff_gnc,
                       gen_cmc_cisf,gen_cmc_gnc,
                       anc_dum_afr,anc_dum_eur,
                       anc_eff_afr,anc_eff_eur,
                       anc_cmc_afr,anc_cmc_eur,
                       res_c_total,res_c_ext,res_c_int,
                       res_c_aggress,res_c_attn,res_c_anxdep,res_c_withdep,
                       res_c_rule,res_c_social,res_c_somatic,res_c_thought,
                       # res_k_adhd, #only 1 afr, 2 amadmix, 6 eur cases so do not analyze
                       # res_k_gad,res_k_mdd,res_k_ptsd,
                       res_k_life_adhd,res_k_life_anx,
                       res_k_life_mdd,res_k_life_ptsd,
                       raw_c_total,raw_c_ext,raw_c_int,
                       raw_c_aggress,raw_c_attn,raw_c_anxdep,raw_c_withdep,
                       raw_c_rule,raw_c_social,raw_c_somatic,raw_c_thought,
                       # raw_k_adhd, #only 1 afr, 2 amadmix, 6 eur cases so do not analyze
                       # raw_k_gad,raw_k_mdd,raw_k_ptsd
                       raw_k_life_adhd,raw_k_life_anx,
                       raw_k_life_mdd,raw_k_life_ptsd
                       )

# yr4_reg_data$anc_cmc_afr <- as.numeric(center(yr4_reg_data$anc_eff_afr,type="CWC", 
#                                               cluster = yr4_reg_data$site))
# yr4_reg_data$anc_cmc_eur <- as.numeric(center(yr4_reg_data$anc_eff_eur,type="CWC", 
#                                               cluster = yr4_reg_data$site))



```

``` {makes plots for inputs and outputs}
ggplot(aes(x=site,fill=gender),data=yr4_reg_data) +
  geom_bar(position="dodge") +
  theme_classic() +
  scale_y_continuous(expand = c(0, 0))
ggplot(aes(y=age,x=gender),data=yr4_reg_data) +
  geom_violin(fill="lightblue") +
  geom_boxplot(width=0.2,alpha=0.2) +
  theme_classic() +
  scale_y_continuous(expand = c(0, 0))
ggplot(aes(y=income_to_needs,x=gender),data=yr4_reg_data) +
  geom_violin(fill="lightblue") +
  geom_boxplot(width=0.2,alpha=0.2) +
  theme_classic() 
ggplot(aes(x=ancestry,fill=gender),data=yr4_reg_data) +
  # geom_violin(fill="lightblue") +
  # geom_boxplot(width=0.2,alpha=0.2) +
  geom_bar(position="dodge") +
  theme_classic() 
ggplot(aes(y=raw_c_total,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_c_total,x=gender),data=yr4_reg_data) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.2) +  # Add jittered points with transparency
  geom_boxplot(width=0.3,alpha=0.2,fill="lightblue") +
  labs(x="Gender",y="Total Problems") +
  scale_x_discrete(labels = c("Cis F", "Cis M", "GD")) +
  theme_classic() 
ggplot(aes(y=raw_c_ext,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_c_ext,x=gender),data=yr4_reg_data) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.2) +  # Add jittered points with transparency
  geom_boxplot(width=0.3,alpha=0.2,fill="lightblue") +
  labs(x="Gender",y="Externalizing Problems") +
  scale_x_discrete(labels = c("Cis F", "Cis M", "GD")) +
  theme_classic() 
ggplot(aes(y=raw_c_int,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_c_int,x=gender),data=yr4_reg_data) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.2) +  # Add jittered points with transparency
  geom_boxplot(width=0.3,alpha=0.2,fill="lightblue") +
  labs(x="Gender",y="Internalizing Problems") +
  scale_x_discrete(labels = c("Cis F", "Cis M", "GD")) +
  theme_classic() 
ggplot(aes(y=raw_c_aggress,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_c_aggress,x=gender),data=yr4_reg_data) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.2) +  # Add jittered points with transparency
  geom_boxplot(width=0.3,alpha=0.2,fill="lightblue") +
  labs(x="Gender",y="Aggression Problems") +
  scale_x_discrete(labels = c("Cis F", "Cis M", "GD")) +
  theme_classic() 
ggplot(aes(y=raw_c_attn,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_c_attn,x=gender),data=yr4_reg_data) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.2) +  # Add jittered points with transparency
  geom_boxplot(width=0.3,alpha=0.2,fill="lightblue") +
  labs(x="Gender",y="Attention Problems") +
  scale_x_discrete(labels = c("Cis F", "Cis M", "GD")) +
  theme_classic() 
ggplot(aes(y=raw_c_anxdep,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_c_anxdep,x=gender),data=yr4_reg_data) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.2) +  # Add jittered points with transparency
  geom_boxplot(width=0.3,alpha=0.2,fill="lightblue") +
  labs(x="Gender",y="Anxious/Depressed Problems") +
  scale_x_discrete(labels = c("Cis F", "Cis M", "GD")) +
  theme_classic() 
ggplot(aes(y=raw_c_withdep,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_c_withdep,x=gender),data=yr4_reg_data) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.2) +  # Add jittered points with transparency
  geom_boxplot(width=0.3,alpha=0.2,fill="lightblue") +
  labs(x="Gender",y="Withdrawn/Depressed Problems") +
  scale_x_discrete(labels = c("Cis F", "Cis M", "GD")) +
  theme_classic() 
ggplot(aes(y=raw_c_rule,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_c_rule,x=gender),data=yr4_reg_data) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.2) +  # Add jittered points with transparency
  geom_boxplot(width=0.3,alpha=0.2,fill="lightblue") +
  labs(x="Gender",y="Rule-breaking Problems") +
  scale_x_discrete(labels = c("Cis F", "Cis M", "GD")) +
  theme_classic() 
ggplot(aes(y=raw_c_social,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_c_social,x=gender),data=yr4_reg_data) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.2) +  # Add jittered points with transparency
  geom_boxplot(width=0.3,alpha=0.2,fill="lightblue") +
  labs(x="Gender",y="Social Problems") +
  scale_x_discrete(labels = c("Cis F", "Cis M", "GD")) +
  theme_classic() 
ggplot(aes(y=raw_c_somatic,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_c_somatic,x=gender),data=yr4_reg_data) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.2) +  # Add jittered points with transparency
  geom_boxplot(width=0.3,alpha=0.2,fill="lightblue") +
  labs(x="Gender",y="Somatic Problems") +
  scale_x_discrete(labels = c("Cis F", "Cis M", "GD")) +
  theme_classic() 
ggplot(aes(y=raw_c_thought,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_c_thought,x=gender),data=yr4_reg_data) +
  geom_violin() +
  geom_jitter(width = 0.1, alpha = 0.2) +  # Add jittered points with transparency
  geom_boxplot(width=0.3,alpha=0.2,fill="lightblue") +
  labs(x="Gender",y="Thought Problems") +
  scale_x_discrete(labels = c("Cis F", "Cis M", "GD")) +
  theme_classic() 

test <- yr4_reg_data %>% group_by(gender,raw_k_gad) %>% count()
test2 <- test %>% group_by(gender) %>%   mutate(prop = n / sum(n))
ggplot(test2, aes(x = as.factor(raw_k_gad), y = prop, fill = gender)) +
  geom_bar(stat = "identity", position = "dodge")  +
  labs(title="Eur Ancestry",
        x = "GAD",
       y = "Proportion",
       fill = "Gender") +
  scale_y_continuous(expand=c(0,0),limits=c(0,1)) +
  scale_fill_manual(values = c("purple","green","blue"),
                    labels = c("Cis F", "Cis M", "GD")) +
  theme_bw() + 
  theme(plot.title = element_text(hjust = 0.5)) 

test <- yr4_reg_data %>% group_by(gender,raw_k_mdd) %>% count()
test2 <- test %>% group_by(gender) %>%   mutate(prop = n / sum(n))
ggplot(test2, aes(x = as.factor(raw_k_mdd), y = prop, fill = gender)) +
  geom_bar(stat = "identity", position = "dodge")  +
  labs(title="Eur Ancestry",
        x = "MDD",
       y = "Proportion",
       fill = "Gender") +
  scale_y_continuous(expand=c(0,0),limits=c(0,1)) +
  scale_fill_manual(values = c("purple","green","blue"),
                    labels = c("Cis F", "Cis M", "GD")) +
  theme_bw() + 
  theme(plot.title = element_text(hjust = 0.5)) 

test <- yr4_reg_data %>% group_by(gender,raw_k_ptsd) %>% count()
test2 <- test %>% group_by(gender) %>%   mutate(prop = n / sum(n))
ggplot(test2, aes(x = as.factor(raw_k_ptsd), y = prop, fill = gender)) +
  geom_bar(stat = "identity", position = "dodge")  +
  labs(title="Eur Ancestry",
        x = "PTSD",
       y = "Proportion",
       fill = "Gender") +
  scale_y_continuous(expand=c(0,0),limits=c(0,1)) +
  scale_fill_manual(values = c("purple","green","blue"),
                    labels = c("Cis F", "Cis M", "GD")) +
  theme_bw() + 
  theme(plot.title = element_text(hjust = 0.5)) 






ggplot(aes(x=zcmc_prs,fill=as.factor(raw_k_ptsd)),data=yr4_reg_data) +
  geom_histogram(binwidth=0.5) +
  # labs(x="PRS (Z Score)",y="Count",title="Am Admix Ancestry",fill="GAD") +
  geom_vline(xintercept=-1.200471,color="blue") +
  geom_vline(xintercept=0.03260305,color="black") +
  # xlim(-7,8) +
  scale_y_continuous(expand=c(0,0),limits=c(0,60)) +
  theme_bw() +


# ggplot(aes(y=raw_k_adhd,x=gender),data=yr4_reg_data) +
# ggplot(aes(y=res_k_adhd,x=gender),data=yr4_reg_data) +
#   geom_boxplot() +
#   theme_classic()
# ggplot(aes(y=raw_k_gad,x=gender),data=yr4_reg_data) +
#   geom_boxplot() +
#   theme_classic()
# ggplot(aes(y=raw_k_mdd,x=gender),data=yr4_reg_data) +
#   geom_boxplot() +
#   theme_classic() 
# ggplot(aes(y=raw_k_ptsd,x=gender),data=yr4_reg_data) +
#   geom_boxplot() +
#   theme_classic() 


```

``` {icc for x variables, r}

### Obtaining ICCs for L1 Predictors (Intercept-Only Model for X) ----
income_to_needs_M0 <- lmer(income_to_needs ~ (1|site), data=yr4_reg_data, REML=FALSE)
summary(income_to_needs_M0)
variances = as.data.frame(VarCorr(income_to_needs_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_income_to_needs <- cluster_var/(cluster_var + resid_var)
ICC_income_to_needs #15% of the variance in income-to-needs is explained by site

age_M0 <- lmer(age ~ (1|site), data=yr4_reg_data, REML=FALSE)
summary(age_M0)
variances = as.data.frame(VarCorr(age_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_age <- cluster_var/(cluster_var + resid_var)
ICC_age #11% of the variance in age is explained by site

prs_M0 <- lmer(prs ~ (1|site), data=yr4_reg_data, REML=FALSE)
summary(prs_M0)
variances = as.data.frame(VarCorr(prs_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_prs <- cluster_var/(cluster_var + resid_var)
ICC_prs #1% of the variance in PRS is explained by site

```

``` {prs~ancestry and covar regressions, r}

## PRS score ----
### Intercept-Only Model Estimation (for Y) ----
prs_M0 <- lmer(zcmc_prs ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(prs_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(prs_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in total problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
prs_M1a_gender <- lmer(zcmc_prs ~ zcmc_age + zcmc_income +
                              anc_cmc_afr + anc_cmc_eur +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(prs_M1a_gender)
prs_M1a_sex <- lmer(zcmc_prs ~ zcmc_age + zcmc_income +
                              anc_cmc_afr + anc_cmc_eur +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(prs_M1a_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
prs_M2a_gender <- lmer(zcmc_prs ~ zcmc_age + zcmc_income +
                        anc_cmc_afr + anc_cmc_eur +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+anc_cmc_afr|site)+(0+anc_cmc_eur|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(prs_M2a_gender)
prs_M2a_sex <- lmer(zcmc_prs ~ zcmc_age + zcmc_income +
                        anc_cmc_afr + anc_cmc_eur +
                        sex_cmc_cisf + 
                      (1|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+anc_cmc_afr|site)+(0+anc_cmc_eur|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(prs_M2a_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# gender failed to converge with either optimizer
# prs_M2c_gender <- lmer(zcmc_prs ~ zcmc_age + zcmc_income +
#                         anc_cmc_afr + anc_cmc_eur +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                       (1+zcmc_income+zcmc_age+
#                          anc_cmc_afr + anc_cmc_eur +
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(prs_M2c_gender)
# sex failed to converge with either optimizer
# prs_M2c_sex <- lmer(zcmc_prs ~ zcmc_age + zcmc_income +
#                         anc_cmc_afr + anc_cmc_eur +
#                         sex_cmc_cisf +
#                       (1+zcmc_income+zcmc_age+
#                          anc_cmc_afr + anc_cmc_eur +
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(prs_M2c_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(prs_M1a_sex,prs_M2a_sex,test="Chisq") #1a is better

anova(prs_M1a_gender,prs_M2a_gender,test="Chisq") #1a is better

# 1a gender: aic = 14562.7, bic = 14617.3
# 1a sex: aic = 14562.2, bic = 14610.7
# all: choose model 1a sex

### Sig Results ----
## no sig results

```

### Compare gender vs sex models (cbcl and ksads) for eur ancestry only (too few gnc in afr or amadmix)

``` {eur cbcl~prs and covar regressions - total problems,r}

## Total problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_total_M0 <- lmer(res_c_total ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_total_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # 0.6% of the variance in total problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_total_M1a_gender <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M1a_gender)
cbcl_total_M1a_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_total_M1b_gender <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M1b_gender)
cbcl_total_M1b_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_total_M2a_gender <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_total_M2a_gender)
cbcl_total_M2a_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_total_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_total_M2b_gender <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_total_M2b_gender)
cbcl_total_M2b_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_total_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_total_M2c_gender <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        gen_cmc_cisf + gen_cmc_gnc |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_total_M2c_gender)
# sex failed to converge with either optimizer
# cbcl_total_M2c_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_total_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_total_M2d_gender <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        gen_cmc_cisf + gen_cmc_gnc |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_total_M2d_gender)
# sex failed to converge with either optimizer
# cbcl_total_M2d_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_total_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_total_M1a_sex,cbcl_total_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_total_M1a_sex,cbcl_total_M2a_sex,test="Chisq") #1a is better
anova(cbcl_total_M1a_sex,cbcl_total_M2b_sex,test="Chisq") #1a is better

anova(cbcl_total_M1a_gender,cbcl_total_M1b_gender,test="Chisq")  #1a is better
anova(cbcl_total_M1a_gender,cbcl_total_M2a_gender,test="Chisq") #1a is better
anova(cbcl_total_M1a_gender,cbcl_total_M2b_gender,test="Chisq") #1a is better
anova(cbcl_total_M1a_gender,cbcl_total_M2c_gender,test="Chisq") #1a is better
anova(cbcl_total_M1a_gender,cbcl_total_M2d_gender,test="Chisq") #1a is better

# 1a gender: bic = 10301.0  
# 1a sex: bic = 10269.7    
# all: choose model 1a sex
eur_cbcl_total_M1a_sex <- cbcl_total_M1a_sex
eur_cbcl_total_M1a_gender <- cbcl_total_M1a_gender

### Sig Results ----
## income: p = 0.0000528, beta = -0.20669        

### total variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original total variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_total) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_total_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_total <- 1 - res_var/orig_Y_var
R2_total

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_total_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_total_M1a_sex)$coef), #predictor names
                          summary(cbcl_total_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_total))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_total_M1a_sex_Yhat <- as.numeric(predict(cbcl_total_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_total_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_total_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_total_M1a_sex_L1resid <- as.numeric(resid(cbcl_total_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_total_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_total_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_total_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_total_M1a_sex)$site)

## Assumption #1 Linearity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_total_M1a_sex_Yhat,
           y=Zcbcl_total_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_total_M1a_sex_robustSE <- rlmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M1a_sex_robustSE)
summary(cbcl_total_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_cbcl_total_M1a_sex_robustSE <- cbcl_total_M1a_sex_robustSE
# similar enough that fan pattern not concerning
data.frame(summary(cbcl_total_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_total_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_total_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_total_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_total_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {eur cbcl~prs and covar regressions - externalizing problems,r}

## Ext problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_ext_M0 <- lmer(res_c_ext ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_ext_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # 0.3% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_ext_M1a_gender <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M1a_gender)
cbcl_ext_M1a_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_ext_M1b_gender <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M1b_gender)
cbcl_ext_M1b_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_ext_M2a_gender <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_ext_M2a_gender)
cbcl_ext_M2a_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_ext_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_ext_M2b_gender <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_ext_M2b_gender)
cbcl_ext_M2b_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_ext_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_ext_M2c_gender <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        gen_cmc_cisf + gen_cmc_gnc |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_ext_M2c_gender)
# sex failed to converge with either optimizer
# cbcl_ext_M2c_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_ext_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# gender failed to converge with either optimizer
# cbcl_ext_M2d_gender <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_ext_M2d_gender)
# sex failed to converge with either optimizer
cbcl_ext_M2d_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_ext_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_ext_M1a_sex,cbcl_ext_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_ext_M1a_sex,cbcl_ext_M2a_sex,test="Chisq") #1a is better
anova(cbcl_ext_M1a_sex,cbcl_ext_M2b_sex,test="Chisq") #1a is better
anova(cbcl_ext_M1a_sex,cbcl_ext_M2d_sex,test="Chisq") #1a is better

anova(cbcl_ext_M1a_gender,cbcl_ext_M1b_gender,test="Chisq")  #1a is better
anova(cbcl_ext_M1a_gender,cbcl_ext_M2a_gender,test="Chisq") #1a is better
anova(cbcl_ext_M1a_gender,cbcl_ext_M2b_gender,test="Chisq") #1a is better
anova(cbcl_ext_M1a_gender,cbcl_ext_M2c_gender,test="Chisq") #1a is better

# 1a gender: bic = 10484.4    
# 1a sex: bic = 10495.3      
# all: choose model 1a gender
eur_cbcl_ext_M1a_gender <- cbcl_ext_M1a_gender
eur_cbcl_ext_M1a_sex <- cbcl_ext_M1a_sex

### Sig Results ----
## income: p = 0.00001459, beta = -0.230827            
## cisf: p = 0.00000289, beta = -0.546838                
## gnc: p = 0.00007455, beta = 0.811530                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_ext) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_ext_M1a_gender)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_ext <- 1 - res_var/orig_Y_var
R2_ext

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_ext_M1a_gender)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_ext_M1a_gender)$coef), #predictor names
                          summary(cbcl_ext_M1a_gender)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_ext))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_ext_M1a_gender_Yhat <- as.numeric(predict(cbcl_ext_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_ext_M1a_gender_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_ext_M1a_gender_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_ext_M1a_gender_L1resid <- as.numeric(resid(cbcl_ext_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_ext_M1a_gender_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_ext_M1a_gender_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_ext_M1a_gender)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_ext_M1a_gender)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_ext_M1a_gender_Yhat,
           y=Zcbcl_ext_M1a_gender_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=gender)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_ext_M1a_gender_robustSE <- rlmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M1a_gender_robustSE)
summary(cbcl_ext_M1a_gender) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_cbcl_ext_M1a_gender_robustSE <- cbcl_ext_M1a_gender_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_ext_M1a_gender_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_ext_M1a_gender)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_ext_M1a_gender_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_ext_M1a_gender_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_ext_M1a_gender_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {eur cbcl~prs and covar regressions - internalizing problems,r}

## int problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_int_M0 <- lmer(res_c_int ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_int_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # 0.1% of the variance in int problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_int_M1a_gender <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M1a_gender)
cbcl_int_M1a_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_int_M1b_gender <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M1b_gender)
cbcl_int_M1b_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_int_M2a_gender <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_int_M2a_gender)
cbcl_int_M2a_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_int_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_int_M2b_gender <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_int_M2b_gender)
cbcl_int_M2b_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_int_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_int_M2c_gender <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        gen_cmc_cisf + gen_cmc_gnc |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_int_M2c_gender)
cbcl_int_M2c_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_int_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_int_M2d_gender <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        gen_cmc_cisf + gen_cmc_gnc |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_int_M2d_gender)
cbcl_int_M2d_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_int_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_int_M1a_sex,cbcl_int_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_int_M1a_sex,cbcl_int_M2a_sex,test="Chisq") #1a is better
anova(cbcl_int_M1a_sex,cbcl_int_M2b_sex,test="Chisq") #1a is better
anova(cbcl_int_M1a_sex,cbcl_int_M2c_sex,test="Chisq") #1a is better
anova(cbcl_int_M1a_sex,cbcl_int_M2d_sex,test="Chisq") #1a is better

anova(cbcl_int_M1a_gender,cbcl_int_M1b_gender,test="Chisq")  #1a is better
anova(cbcl_int_M1a_gender,cbcl_int_M2a_gender,test="Chisq") #1a is better
anova(cbcl_int_M1a_gender,cbcl_int_M2b_gender,test="Chisq") #1a is better
anova(cbcl_int_M1a_gender,cbcl_int_M2c_gender,test="Chisq") #1a is better
anova(cbcl_int_M1a_gender,cbcl_int_M2d_gender,test="Chisq") #1a is better

# 1a gender: bic = 11557.0      
# 1a sex: bic = 11579.0        
# all: choose model 1a gender
eur_cbcl_int_M1a_gender <- cbcl_int_M1a_gender
eur_cbcl_int_M1a_sex <- cbcl_int_M1a_sex

### Sig Results ----
## income: p = 0.00195 , beta = -0.20975                
## cisf: p = 0.00003295309 , beta = -0.61738                    
## gnc: p = 0.00000000182 , beta = 1.57160                    

### int variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original int variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_int) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_int_M1a_gender)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_int <- 1 - res_var/orig_Y_var
R2_int

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### intract residual df 
res_df <- as.numeric(summary(cbcl_int_M1a_gender)$AICtab[5])
res_df 
### intract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_int_M1a_gender)$coef), #predictor names
                          summary(cbcl_int_M1a_gender)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_int))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# intract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_int_M1a_gender_Yhat <- as.numeric(predict(cbcl_int_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_int_M1a_gender_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_int_M1a_gender_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_int_M1a_gender_L1resid <- as.numeric(resid(cbcl_int_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_int_M1a_gender_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_int_M1a_gender_L1resid))

## intract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### intract L2 residuals using ranef() function
intercept <- ranef(cbcl_int_M1a_gender)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_int_M1a_gender)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_int_M1a_gender_Yhat,
           y=Zcbcl_int_M1a_gender_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=gender)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_int_M1a_gender_robustSE <- rlmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M1a_gender_robustSE)
summary(cbcl_int_M1a_gender) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_cbcl_int_M1a_gender_robustSE <- cbcl_int_M1a_gender_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_int_M1a_gender_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_int_M1a_gender)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_int_M1a_gender_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_int_M1a_gender_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_int_M1a_gender_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {eur cbcl~prs and covar regressions - aggressive problems,r}

## aggress problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_aggress_M0 <- lmer(res_c_aggress ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_aggress_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in aggress problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_aggress_M1a_gender <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M1a_gender)
cbcl_aggress_M1a_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_aggress_M1b_gender <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M1b_gender)
cbcl_aggress_M1b_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_aggress_M2a_gender <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_aggress_M2a_gender)
cbcl_aggress_M2a_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_aggress_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_aggress_M2b_gender <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_aggress_M2b_gender)
cbcl_aggress_M2b_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_aggress_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_aggress_M2c_gender <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        gen_cmc_cisf + gen_cmc_gnc |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_aggress_M2c_gender)
cbcl_aggress_M2c_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_aggress_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_aggress_M2d_gender <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        gen_cmc_cisf + gen_cmc_gnc |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_aggress_M2d_gender)
cbcl_aggress_M2d_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_aggress_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M2a_sex,test="Chisq") #1a is better
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M2b_sex,test="Chisq") #1a is better
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M2c_sex,test="Chisq") #1a is better
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M2d_sex,test="Chisq") #1a is better

anova(cbcl_aggress_M1a_gender,cbcl_aggress_M1b_gender,test="Chisq")  #1a is better
anova(cbcl_aggress_M1a_gender,cbcl_aggress_M2a_gender,test="Chisq") #1a is better
anova(cbcl_aggress_M1a_gender,cbcl_aggress_M2b_gender,test="Chisq") #1a is better
anova(cbcl_aggress_M1a_gender,cbcl_aggress_M2c_gender,test="Chisq") #1a is better
anova(cbcl_aggress_M1a_gender,cbcl_aggress_M2d_gender,test="Chisq") #1a is better

# 1a gender: bic = 7586.7      
# 1a sex: bic = 7589.7        
# all: choose model 1a gender
eur_cbcl_aggress_M1a_gender <- cbcl_aggress_M1a_gender
eur_cbcl_aggress_M1a_sex <- cbcl_aggress_M1a_sex

### Sig Results ----
## income: p = 0.0000454 , beta = -0.113455                
## cisf: p = 0.0000509 , beta = -0.247306                    
## gnc: p = 0.00456 , beta = 0.303406                    

### aggress variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original aggress variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_aggress) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_aggress_M1a_gender)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_aggress <- 1 - res_var/orig_Y_var
R2_aggress

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### aggressract residual df 
res_df <- as.numeric(summary(cbcl_aggress_M1a_gender)$AICtab[5])
res_df 
### aggressract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_aggress_M1a_gender)$coef), #predictor names
                          summary(cbcl_aggress_M1a_gender)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_aggress))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# aggressract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_aggress_M1a_gender_Yhat <- as.numeric(predict(cbcl_aggress_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_aggress_M1a_gender_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_aggress_M1a_gender_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_aggress_M1a_gender_L1resid <- as.numeric(resid(cbcl_aggress_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_aggress_M1a_gender_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_aggress_M1a_gender_L1resid))

## aggressract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### aggressract L2 residuals using ranef() function
intercept <- ranef(cbcl_aggress_M1a_gender)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_aggress_M1a_gender)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_aggress_M1a_gender_Yhat,
           y=Zcbcl_aggress_M1a_gender_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=gender)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_aggress_M1a_gender_robustSE <- rlmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M1a_gender_robustSE)
summary(cbcl_aggress_M1a_gender) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_cbcl_aggress_M1a_gender_robustSE <- cbcl_aggress_M1a_gender_robustSE

data.frame(summary(cbcl_aggress_M1a_gender_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_aggress_M1a_gender)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: HEAVILY SKEWED , does not seem like taking log fixes things


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_aggress_M1a_gender_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_aggress_M1a_gender_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_aggress_M1a_gender_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {eur cbcl~prs and covar regressions - attention problems,r}

## Ext problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_attn_M0 <- lmer(res_c_attn ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_attn_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # 0.2% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_attn_M1a_gender <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M1a_gender)
cbcl_attn_M1a_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_attn_M1b_gender <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M1b_gender)
cbcl_attn_M1b_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_attn_M2a_gender <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_attn_M2a_gender)
cbcl_attn_M2a_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_attn_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_attn_M2b_gender <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_attn_M2b_gender)
cbcl_attn_M2b_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_attn_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# gender failed to converge with either optimizer
# cbcl_attn_M2c_gender <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_attn_M2c_gender)
cbcl_attn_M2c_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_attn_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_attn_M2d_gender <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        gen_cmc_cisf + gen_cmc_gnc |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_attn_M2d_gender)
cbcl_attn_M2d_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_attn_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_attn_M1a_sex,cbcl_attn_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2a_sex,test="Chisq") #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2b_sex,test="Chisq") #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2c_sex,test="Chisq") #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2d_sex,test="Chisq") #1a is better

anova(cbcl_attn_M1a_gender,cbcl_attn_M1b_gender,test="Chisq")  #1a is better
anova(cbcl_attn_M1a_gender,cbcl_attn_M2a_gender,test="Chisq") #1a is better
anova(cbcl_attn_M1a_gender,cbcl_attn_M2b_gender,test="Chisq") #1a is better
anova(cbcl_attn_M1a_gender,cbcl_attn_M2d_gender,test="Chisq") #1a is better

# 1a gender: bic = 10680.7    
# 1a sex: bic = 10720.4      
# all: choose model 1a gender
eur_cbcl_attn_M1a_gender <- cbcl_attn_M1a_gender
eur_cbcl_attn_M1a_sex <- cbcl_attn_M1a_sex

### Sig Results ----
## income: p = 0.000828 , beta = -0.185969                
## cisf: p = 0.0000000006516 , beta = -0.756304                 
## gnc: p = 0.0000000000021 , beta = 1.511062                 

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_attn) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_attn_M1a_gender)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_attn <- 1 - res_var/orig_Y_var
R2_attn

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_attn_M1a_gender)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_attn_M1a_gender)$coef), #predictor names
                          summary(cbcl_attn_M1a_gender)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_attn))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_attn_M1a_gender_Yhat <- as.numeric(predict(cbcl_attn_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_attn_M1a_gender_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_attn_M1a_gender_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_attn_M1a_gender_L1resid <- as.numeric(resid(cbcl_attn_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_attn_M1a_gender_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_attn_M1a_gender_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_attn_M1a_gender)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_attn_M1a_gender)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_attn_M1a_gender_Yhat,
           y=Zcbcl_attn_M1a_gender_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=gender)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_attn_M1a_gender_robustSE <- rlmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M1a_gender_robustSE)
summary(cbcl_attn_M1a_gender) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_cbcl_attn_M1a_gender_robustSE <- cbcl_attn_M1a_gender_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_attn_M1a_gender_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_attn_M1a_gender)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_attn_M1a_gender_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

NOTE: HEAVILY SKEWED 

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_attn_M1a_gender_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_attn_M1a_gender_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {eur cbcl~prs and covar regressions - anxious/depressed problems,r}

## Ext problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_anxdep_M0 <- lmer(res_c_anxdep ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_anxdep_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_anxdep_M1a_gender <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M1a_gender)
cbcl_anxdep_M1a_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_anxdep_M1b_gender <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M1b_gender)
cbcl_anxdep_M1b_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_anxdep_M2a_gender <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_anxdep_M2a_gender)
cbcl_anxdep_M2a_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_anxdep_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_anxdep_M2b_gender <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_anxdep_M2b_gender)
cbcl_anxdep_M2b_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_anxdep_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# gender failed to converge with either optimizer
# cbcl_anxdep_M2c_gender <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_anxdep_M2c_gender)
cbcl_anxdep_M2c_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_anxdep_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# gender failed to converge with either optimizer
# cbcl_anxdep_M2d_gender <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_anxdep_M2d_gender)
cbcl_anxdep_M2d_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_anxdep_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M2a_sex,test="Chisq") #1a is better
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M2b_sex,test="Chisq") #1a is better
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M2c_sex,test="Chisq") #1a is better
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M2d_sex,test="Chisq") #1a is better

anova(cbcl_anxdep_M1a_gender,cbcl_anxdep_M1b_gender,test="Chisq")  #1a is better
anova(cbcl_anxdep_M1a_gender,cbcl_anxdep_M2a_gender,test="Chisq") #1a is better
anova(cbcl_anxdep_M1a_gender,cbcl_anxdep_M2b_gender,test="Chisq") #1a is better

# 1a gender: bic = 10137.3    
# 1a sex: bic = 10152.6        
# all: choose model 1a gender
eur_cbcl_anxdep_M1a_gender <- cbcl_anxdep_M1a_gender
eur_cbcl_anxdep_M1a_sex <- cbcl_anxdep_M1a_sex

### Sig Results ----
## cisf: p = 0.000172 , beta = -0.40641                    
## gnc: p = 0.000000119 , beta = 1.00608                    

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_anxdep) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_anxdep_M1a_gender)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_anxdep <- 1 - res_var/orig_Y_var
R2_anxdep

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_anxdep_M1a_gender)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_anxdep_M1a_gender)$coef), #predictor names
                          summary(cbcl_anxdep_M1a_gender)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_anxdep))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_anxdep_M1a_gender_Yhat <- as.numeric(predict(cbcl_anxdep_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_anxdep_M1a_gender_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_anxdep_M1a_gender_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_anxdep_M1a_gender_L1resid <- as.numeric(resid(cbcl_anxdep_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_anxdep_M1a_gender_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_anxdep_M1a_gender_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_anxdep_M1a_gender)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_anxdep_M1a_gender)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_anxdep_M1a_gender_Yhat,
           y=Zcbcl_anxdep_M1a_gender_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=gender)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_anxdep_M1a_gender_robustSE <- rlmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M1a_gender_robustSE)
summary(cbcl_anxdep_M1a_gender) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_cbcl_anxdep_M1a_gender_robustSE <- cbcl_anxdep_M1a_gender_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_anxdep_M1a_gender_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_anxdep_M1a_gender)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: HEAVILY SKEWED 

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_anxdep_M1a_gender_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_anxdep_M1a_gender_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_anxdep_M1a_gender_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {eur cbcl~prs and covar regressions - withdrawn/depressed problems,r}

## Ext problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_withdep_M0 <- lmer(res_c_withdep ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_withdep_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # 0.4% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_withdep_M1a_gender <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M1a_gender)
cbcl_withdep_M1a_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_withdep_M1b_gender <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M1b_gender)
cbcl_withdep_M1b_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_withdep_M2a_gender <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_withdep_M2a_gender)
cbcl_withdep_M2a_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_withdep_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_withdep_M2b_gender <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_withdep_M2b_gender)
cbcl_withdep_M2b_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_withdep_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_withdep_M2c_gender <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        gen_cmc_cisf + gen_cmc_gnc |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_withdep_M2c_gender)
cbcl_withdep_M2c_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_withdep_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# gender failed to converge with either optimizer
# cbcl_withdep_M2d_gender <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_withdep_M2d_gender)
# sex failed to converge with either optimizer
# cbcl_withdep_M2d_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_withdep_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M2a_sex,test="Chisq") #1a is better
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M2b_sex,test="Chisq") #1a is better
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M2c_sex,test="Chisq") #1a is better

anova(cbcl_withdep_M1a_gender,cbcl_withdep_M1b_gender,test="Chisq")  #1a is better
anova(cbcl_withdep_M1a_gender,cbcl_withdep_M2a_gender,test="Chisq") #1a is better
anova(cbcl_withdep_M1a_gender,cbcl_withdep_M2b_gender,test="Chisq") #1a is better
anova(cbcl_withdep_M1a_gender,cbcl_withdep_M2c_gender,test="Chisq") #1a is better

# 1a gender: bic = 8818.4      
# 1a sex: bic = 8853.8        
# all: choose model 1a gender
eur_cbcl_withdep_M1a_gender <- cbcl_withdep_M1a_gender
eur_cbcl_withdep_M1a_sex <- cbcl_withdep_M1a_sex

### Sig Results ----
## income: p = 0.0000673056667 , beta = -0.145920                
## cisf: p = 0.0000000029494 , beta = -0.477784                    
## gnc: p = 0.0000000000398 , beta = 0.933573                    

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_withdep) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_withdep_M1a_gender)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_withdep <- 1 - res_var/orig_Y_var
R2_withdep

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_withdep_M1a_gender)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_withdep_M1a_gender)$coef), #predictor names
                          summary(cbcl_withdep_M1a_gender)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_withdep))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_withdep_M1a_gender_Yhat <- as.numeric(predict(cbcl_withdep_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_withdep_M1a_gender_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_withdep_M1a_gender_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_withdep_M1a_gender_L1resid <- as.numeric(resid(cbcl_withdep_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_withdep_M1a_gender_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_withdep_M1a_gender_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_withdep_M1a_gender)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_withdep_M1a_gender)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_withdep_M1a_gender_Yhat,
           y=Zcbcl_withdep_M1a_gender_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=gender)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_withdep_M1a_gender_robustSE <- rlmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M1a_gender_robustSE)
summary(cbcl_withdep_M1a_gender) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_cbcl_withdep_M1a_gender_robustSE <- cbcl_withdep_M1a_gender_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_withdep_M1a_gender_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_withdep_M1a_gender)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: HEAVILY SKEWED 

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_withdep_M1a_gender_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_withdep_M1a_gender_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_withdep_M1a_gender_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {eur cbcl~prs and covar regressions - rulebreaking problems,r}

## Rulebreaking problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_rule_M0 <- lmer(res_c_rule ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_rule_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # 0.1% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_rule_M1a_gender <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M1a_gender)
cbcl_rule_M1a_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_rule_M1b_gender <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M1b_gender)
cbcl_rule_M1b_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_rule_M2a_gender <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_rule_M2a_gender)
cbcl_rule_M2a_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_rule_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_rule_M2b_gender <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_rule_M2b_gender)
cbcl_rule_M2b_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_rule_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# gender failed to converge with either optimizer
# cbcl_rule_M2c_gender <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_rule_M2c_gender)
cbcl_rule_M2c_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_rule_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# gender failed to converge with either optimizer
# cbcl_rule_M2d_gender <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_rule_M2d_gender)
# sex failed to converge with either optimizer
cbcl_rule_M2d_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_rule_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_rule_M1a_sex,cbcl_rule_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2a_sex,test="Chisq") #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2b_sex,test="Chisq") #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2c_sex,test="Chisq") #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2d_sex,test="Chisq") #1a is better

anova(cbcl_rule_M1a_gender,cbcl_rule_M1b_gender,test="Chisq")  #1a is better
anova(cbcl_rule_M1a_gender,cbcl_rule_M2a_gender,test="Chisq") #1a is better
anova(cbcl_rule_M1a_gender,cbcl_rule_M2b_gender,test="Chisq") #1a is better

# 1a gender: bic = 6168.5      
# 1a sex: bic = 6176.2        
# all: choose model 1a gender
eur_cbcl_rule_M1a_gender <- cbcl_rule_M1a_gender
eur_cbcl_rule_M1a_sex <- cbcl_rule_M1a_sex

### Sig Results ----
## income: p = 0.00000977 , beta = -0.089457                
## cisf: p = 0.000149 , beta = -0.168242                    
## gnc: p = 0.000126 , beta = 0.298328                    

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_rule) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_rule_M1a_gender)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_rule <- 1 - res_var/orig_Y_var
R2_rule

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_rule_M1a_gender)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_rule_M1a_gender)$coef), #predictor names
                          summary(cbcl_rule_M1a_gender)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_rule))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_rule_M1a_gender_Yhat <- as.numeric(predict(cbcl_rule_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_rule_M1a_gender_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_rule_M1a_gender_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_rule_M1a_gender_L1resid <- as.numeric(resid(cbcl_rule_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_rule_M1a_gender_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_rule_M1a_gender_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_rule_M1a_gender)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_rule_M1a_gender)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_rule_M1a_gender_Yhat,
           y=Zcbcl_rule_M1a_gender_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=gender)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_rule_M1a_gender_robustSE <- rlmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M1a_gender_robustSE)
summary(cbcl_rule_M1a_gender) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_cbcl_rule_M1a_gender_robustSE <- cbcl_rule_M1a_gender_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_rule_M1a_gender_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_rule_M1a_gender)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: HEAVILY SKEWED 

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_rule_M1a_gender_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_rule_M1a_gender_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_rule_M1a_gender_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {eur cbcl~prs and covar regressions - social problems,r}

## Ext problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_social_M0 <- lmer(res_c_social ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_social_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_social_M1a_gender <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M1a_gender)
cbcl_social_M1a_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_social_M1b_gender <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M1b_gender)
cbcl_social_M1b_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_social_M2a_gender <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_social_M2a_gender)
cbcl_social_M2a_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_social_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_social_M2b_gender <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_social_M2b_gender)
cbcl_social_M2b_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_social_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# gender failed to converge with either optimizer
# cbcl_social_M2c_gender <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_social_M2c_gender)
# sex failed to converge with either optimizer
# cbcl_social_M2c_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_social_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# gender failed to converge with either optimizer
# cbcl_social_M2d_gender <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_social_M2d_gender)
# sex failed to converge with either optimizer
# cbcl_social_M2d_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_social_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_social_M1a_sex,cbcl_social_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_social_M1a_sex,cbcl_social_M2a_sex,test="Chisq") #1a is better
anova(cbcl_social_M1a_sex,cbcl_social_M2b_sex,test="Chisq") #1a is better

anova(cbcl_social_M1a_gender,cbcl_social_M1b_gender,test="Chisq")  #1a is better
anova(cbcl_social_M1a_gender,cbcl_social_M2a_gender,test="Chisq") #1a is better
anova(cbcl_social_M1a_gender,cbcl_social_M2b_gender,test="Chisq") #1a is better

# 1a gender: bic = 8355.4      
# 1a sex: bic = 8356.8        
# all: choose model 1a gender
eur_cbcl_social_M1a_gender <- cbcl_social_M1a_gender
eur_cbcl_social_M1a_sex <- cbcl_social_M1a_sex

### Sig Results ----
## income: p = 0.00000193 , beta = -0.1574843                
## cisf: p = 0.00247 , beta = -0.2193797                    
## gnc: p = 0.00517 , beta = 0.3554282                    

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_social) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_social_M1a_gender)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_social <- 1 - res_var/orig_Y_var
R2_social

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_social_M1a_gender)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_social_M1a_gender)$coef), #predictor names
                          summary(cbcl_social_M1a_gender)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_social))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_social_M1a_gender_Yhat <- as.numeric(predict(cbcl_social_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_social_M1a_gender_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_social_M1a_gender_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_social_M1a_gender_L1resid <- as.numeric(resid(cbcl_social_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_social_M1a_gender_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_social_M1a_gender_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_social_M1a_gender)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_social_M1a_gender)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_social_M1a_gender_Yhat,
           y=Zcbcl_social_M1a_gender_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=gender)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_social_M1a_gender_robustSE <- rlmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M1a_gender_robustSE)
summary(cbcl_social_M1a_gender) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_cbcl_social_M1a_gender_robustSE <- cbcl_social_M1a_gender_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_social_M1a_gender_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_social_M1a_gender)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: HEAVILY SKEWED 

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_social_M1a_gender_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_social_M1a_gender_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_social_M1a_gender_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {eur cbcl~prs and covar regressions - somatic problems,r}

## Ext problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_somatic_M0 <- lmer(res_c_somatic ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_somatic_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # 0.7% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_somatic_M1a_gender <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M1a_gender)
cbcl_somatic_M1a_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_somatic_M1b_gender <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M1b_gender)
cbcl_somatic_M1b_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_somatic_M2a_gender <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_somatic_M2a_gender)
cbcl_somatic_M2a_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_somatic_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_somatic_M2b_gender <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_somatic_M2b_gender)
cbcl_somatic_M2b_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_somatic_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# gender failed to converge with either optimizer
# cbcl_somatic_M2c_gender <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_somatic_M2c_gender)
# sex failed to converge with either optimizer
# cbcl_somatic_M2c_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_somatic_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# gender failed to converge with either optimizer
# cbcl_somatic_M2d_gender <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_somatic_M2d_gender)
# sex failed to converge with either optimizer
# cbcl_somatic_M2d_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_somatic_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M2a_sex,test="Chisq") #1a is better
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M2b_sex,test="Chisq") #1a is better

anova(cbcl_somatic_M1a_gender,cbcl_somatic_M1b_gender,test="Chisq")  #1a is better
anova(cbcl_somatic_M1a_gender,cbcl_somatic_M2a_gender,test="Chisq") #1a is better
anova(cbcl_somatic_M1a_gender,cbcl_somatic_M2b_gender,test="Chisq") #1a is better

# 1a gender: bic = 10487.5      
# 1a sex: bic = 10503.2        
# all: choose model 1a gender
eur_cbcl_somatic_M1a_gender <- cbcl_somatic_M1a_gender
eur_cbcl_somatic_M1a_sex <- cbcl_somatic_M1a_sex

### Sig Results ----
## income: p = 0.000484 , beta = -0.18557                
## cisf: p = 0.0000586035 , beta = -0.46912                    
## gnc: p = 0.0000000844 , beta = 1.09853                    

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_somatic) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_somatic_M1a_gender)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_somatic <- 1 - res_var/orig_Y_var
R2_somatic

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_somatic_M1a_gender)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_somatic_M1a_gender)$coef), #predictor names
                          summary(cbcl_somatic_M1a_gender)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_somatic))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_somatic_M1a_gender_Yhat <- as.numeric(predict(cbcl_somatic_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_somatic_M1a_gender_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_somatic_M1a_gender_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_somatic_M1a_gender_L1resid <- as.numeric(resid(cbcl_somatic_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_somatic_M1a_gender_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_somatic_M1a_gender_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_somatic_M1a_gender)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_somatic_M1a_gender)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_somatic_M1a_gender_Yhat,
           y=Zcbcl_somatic_M1a_gender_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=gender)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_somatic_M1a_gender_robustSE <- rlmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M1a_gender_robustSE)
summary(cbcl_somatic_M1a_gender) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_cbcl_somatic_M1a_gender_robustSE <- cbcl_somatic_M1a_gender_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_somatic_M1a_gender_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_somatic_M1a_gender)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: HEAVILY SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_somatic_M1a_gender_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_somatic_M1a_gender_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_somatic_M1a_gender_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {eur cbcl~prs and covar regressions - thought problems,r}

## Ext problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_thought_M0 <- lmer(res_c_thought ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_thought_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_thought_M1a_gender <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M1a_gender)
cbcl_thought_M1a_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_thought_M1b_gender <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M1b_gender)
cbcl_thought_M1b_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_thought_M2a_gender <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_thought_M2a_gender)
cbcl_thought_M2a_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_thought_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_thought_M2b_gender <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_thought_M2b_gender)
cbcl_thought_M2b_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_thought_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# gender failed to converge with either optimizer
# cbcl_thought_M2c_gender <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_thought_M2c_gender)
# sex failed to converge with either optimizer
# cbcl_thought_M2c_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_thought_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# gender failed to converge with either optimizer
# cbcl_thought_M2d_gender <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_thought_M2d_gender)
# sex failed to converge with either optimizer
# cbcl_thought_M2d_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_thought_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_thought_M1a_sex,cbcl_thought_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_thought_M1a_sex,cbcl_thought_M2a_sex,test="Chisq") #1a is better
anova(cbcl_thought_M1a_sex,cbcl_thought_M2b_sex,test="Chisq") #1a is better

anova(cbcl_thought_M1a_gender,cbcl_thought_M1b_gender,test="Chisq")  #1a is better
anova(cbcl_thought_M1a_gender,cbcl_thought_M2a_gender,test="Chisq") #1a is better
anova(cbcl_thought_M1a_gender,cbcl_thought_M2b_gender,test="Chisq") #1a is better

# 1a gender: bic = 8810.5      
# 1a sex: bic = 8877.2        
# all: choose model 1a gender
eur_cbcl_thought_M1a_gender <- cbcl_thought_M1a_gender
eur_cbcl_thought_M1a_sex <- cbcl_thought_M1a_sex

### Sig Results ----
## income: p = 0.00247 , beta = -0.11071                
## cisf: p = 0.0000000000000185 , beta = -0.61836                    
## gnc: p = < 0.0000000000000002 , beta = 1.24461                    

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_thought) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_thought_M1a_gender)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_thought <- 1 - res_var/orig_Y_var
R2_thought

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_thought_M1a_gender)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_thought_M1a_gender)$coef), #predictor names
                          summary(cbcl_thought_M1a_gender)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_thought_M1a_gender_Yhat <- as.numeric(predict(cbcl_thought_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_thought_M1a_gender_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_thought_M1a_gender_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_thought_M1a_gender_L1resid <- as.numeric(resid(cbcl_thought_M1a_gender))
# create Z score version
yr4_reg_data$Zcbcl_thought_M1a_gender_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_thought_M1a_gender_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_thought_M1a_gender)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_thought_M1a_gender)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_thought_M1a_gender_Yhat,
           y=Zcbcl_thought_M1a_gender_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=gender)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_thought_M1a_gender_robustSE <- rlmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M1a_gender_robustSE)
summary(cbcl_thought_M1a_gender) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_cbcl_thought_M1a_gender_robustSE <- cbcl_thought_M1a_gender_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_thought_M1a_gender_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_thought_M1a_gender)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: HEAVILY SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_thought_M1a_gender_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_thought_M1a_gender_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_thought_M1a_gender_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {eur ksads~prs and covar regressions - gad,r}

## gad ----
### Intercept-Only Model Estimation (for Y) ----
# ksads_gad_M0 <- lmer(res_k_gad ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
ksads_anx_M0 <- lmer(res_k_life_anx ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
# summary(ksads_gad_M0)
summary(ksads_anx_M0)

### computing the ICC for Y using variance components ----
# variances = as.data.frame(VarCorr(ksads_gad_M0))
variances = as.data.frame(VarCorr(ksads_anx_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
# ICC_Y2 # <0.01% of the variance in gad diagnoses is explained by site
ICC_Y2 # 0.5% of the variance in anxiety diagnoses is explained by site

### Random Intercept, Fixed Slopes without interactions ----
# ksads_gad_M1a_gender <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
ksads_life_anx_M1a_gender <- lmer(res_k_life_anx ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
# summary(ksads_gad_M1a_gender)
summary(ksads_life_anx_M1a_gender)
# ksads_gad_M1a_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
ksads_life_anx_M1a_sex <- lmer(res_k_life_anx ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
# summary(ksads_gad_M1a_sex)
summary(ksads_life_anx_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
# ksads_gad_M1b_gender <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
ksads_life_anx_M1b_gender <- lmer(res_k_life_anx ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
# summary(ksads_gad_M1b_gender)
summary(ksads_life_anx_M1b_gender)
# ksads_gad_M1b_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
ksads_life_anx_M1b_sex <- lmer(res_k_life_anx ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
# summary(ksads_gad_M1b_sex)
summary(ksads_life_anx_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
# ksads_gad_M2a_gender <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
ksads_life_anx_M2a_gender <- lmer(res_k_life_anx ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_gad_M2a_gender)
summary(ksads_life_anx_M2a_gender)
# ksads_gad_M2a_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
ksads_life_anx_M2a_sex <- lmer(res_k_life_anx ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_gad_M2a_sex)
summary(ksads_life_anx_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
# ksads_gad_M2b_gender <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
ksads_life_anx_M2b_gender <- lmer(res_k_life_anx ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
# summary(ksads_gad_M2b_gender)
summary(ksads_life_anx_M2b_gender)
# ksads_gad_M2b_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
ksads_life_anx_M2b_sex <- lmer(res_k_life_anx ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
# summary(ksads_gad_M2b_sex)
summary(ksads_life_anx_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# gender failed to converge with either optimizer
# ksads_gad_M2c_gender <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
# ksads_life_anx_M2c_gender <- lmer(res_k_life_anx ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_gad_M2c_gender)
# summary(ksads_life_anx_M2c_gender)
# sex failed to converge with either optimizer
# ksads_gad_M2c_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
# ksads_life_anx_M2c_sex <- lmer(res_k_life_anx ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# # summary(ksads_gad_M2c_sex)
# summary(ksads_life_anx_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# gender failed to converge with either optimizer
# ksads_gad_M2d_gender <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_gad_M2d_gender)
ksads_gad_M2d_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_gad_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(ksads_gad_M1a_sex,ksads_gad_M1b_sex,test="Chisq")  #1a is better
anova(ksads_gad_M1a_sex,ksads_gad_M2a_sex,test="Chisq") #1a is better
anova(ksads_gad_M1a_sex,ksads_gad_M2b_sex,test="Chisq") #1a is better
anova(ksads_gad_M1a_sex,ksads_gad_M2c_sex,test="Chisq") #1a is better
anova(ksads_gad_M1a_sex,ksads_gad_M2d_sex,test="Chisq") #1a is better

anova(ksads_gad_M1a_gender,ksads_gad_M1b_gender,test="Chisq")  #1a is better
anova(ksads_gad_M1a_gender,ksads_gad_M2a_gender,test="Chisq") #1a is better
anova(ksads_gad_M1a_gender,ksads_gad_M2b_gender,test="Chisq") #1a is better

# 1a gender: bic = 11485.8          
# 1a sex: bic = 11496.5            
# all: choose model 1a gender
eur_ksads_gad_M1a_gender <- ksads_gad_M1a_gender
eur_ksads_gad_M1a_sex <- ksads_gad_M1a_sex

### Sig Results ----
## cisf: p = 0.00714   , beta = -0.39357                            
## gnc: p = 0.00000148    , beta = 1.23742                                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_k_gad) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(ksads_gad_M1a_gender)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_gad <- 1 - res_var/orig_Y_var
R2_gad

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(ksads_gad_M1a_gender)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(ksads_gad_M1a_gender)$coef), #predictor names
                          summary(ksads_gad_M1a_gender)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$ksads_gad_M1a_gender_Yhat <- as.numeric(predict(ksads_gad_M1a_gender))
# create Z score version
yr4_reg_data$Zksads_gad_M1a_gender_Yhat <- as.numeric(scale(yr4_reg_data$ksads_gad_M1a_gender_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$ksads_gad_M1a_gender_L1resid <- as.numeric(resid(ksads_gad_M1a_gender))
# create Z score version
yr4_reg_data$Zksads_gad_M1a_gender_L1resid <- as.numeric(
                                                scale(yr4_reg_data$ksads_gad_M1a_gender_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(ksads_gad_M1a_gender)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(ksads_gad_M1a_gender)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zksads_gad_M1a_gender_Yhat,
           y=Zksads_gad_M1a_gender_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=gender)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
ksads_gad_M1a_gender_robustSE <- rlmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_gad_M1a_gender_robustSE)
summary(ksads_gad_M1a_gender) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_ksads_gad_M1a_gender_robustSE <- ksads_gad_M1a_gender_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(ksads_gad_M1a_gender_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(ksads_gad_M1a_gender)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: SOME RESIDUALS ARE VERY VERY LARGE
NOTE: THESE ARE EXTREMELY DIFFERENT
NOTE: HEAVILY SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zksads_gad_M1a_gender_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zksads_gad_M1a_gender_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zksads_gad_M1a_gender_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {eur ksads~prs and covar regressions - mdd,r}

## mdd ----
### Intercept-Only Model Estimation (for Y) ----
ksads_mdd_M0 <- lmer(res_k_mdd ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(ksads_mdd_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # 0.3% of the variance in mdd diagnoses is explained by site

### Random Intercept, Fixed Slopes without interactions ----
ksads_mdd_M1a_gender <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M1a_gender)
ksads_mdd_M1a_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
ksads_mdd_M1b_gender <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M1b_gender)
ksads_mdd_M1b_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
ksads_mdd_M2a_gender <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_mdd_M2a_gender)
# sex failed to converge with either optimizer
ksads_mdd_M2a_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_mdd_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
ksads_mdd_M2b_gender <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(ksads_mdd_M2b_gender)
ksads_mdd_M2b_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(ksads_mdd_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# gender failed to converge with either optimizer
# ksads_mdd_M2c_gender <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_mdd_M2c_gender)
# sex failed to converge with either optimizer
# ksads_mdd_M2c_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_mdd_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# gender failed to converge with either optimizer
# ksads_mdd_M2d_gender <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_mdd_M2d_gender)
ksads_mdd_M2d_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_mdd_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(ksads_mdd_M1a_sex,ksads_mdd_M1b_sex,test="Chisq")  #1a is better
anova(ksads_mdd_M1a_sex,ksads_mdd_M2a_sex,test="Chisq") #1a is better
anova(ksads_mdd_M1a_sex,ksads_mdd_M2b_sex,test="Chisq") #1a is better
anova(ksads_mdd_M1a_sex,ksads_mdd_M2d_sex,test="Chisq") #1a is better

anova(ksads_mdd_M1a_gender,ksads_mdd_M1b_gender,test="Chisq")  #1a is better
anova(ksads_mdd_M1a_gender,ksads_mdd_M2a_gender,test="Chisq") #2a is better
anova(ksads_mdd_M2a_gender,ksads_mdd_M2b_gender,test="Chisq") #2b is better

# 2b gender: bic = 14407.4            
# 1a sex: bic = 14391.7              
# all: choose model 1a sex
eur_ksads_mdd_M2b_gender <- ksads_mdd_M2b_gender
eur_ksads_mdd_M1a_sex <- ksads_mdd_M1a_sex

### Sig Results ----
## cisf: p = 0.00000133    , beta = 0.62489                                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_k_mdd) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(ksads_mdd_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_mdd <- 1 - res_var/orig_Y_var
R2_mdd



## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(ksads_mdd_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(ksads_mdd_M1a_sex)$coef), #predictor names
                          summary(ksads_mdd_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$ksads_mdd_M1a_sex_Yhat <- as.numeric(predict(ksads_mdd_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_mdd_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$ksads_mdd_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$ksads_mdd_M1a_sex_L1resid <- as.numeric(resid(ksads_mdd_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_mdd_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$ksads_mdd_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(ksads_mdd_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(ksads_mdd_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zksads_mdd_M1a_sex_Yhat,
           y=Zksads_mdd_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
ksads_mdd_M1a_sex_robustSE <- rlmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M1a_sex_robustSE)
summary(ksads_mdd_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_ksads_mdd_M1a_sex_robustSE <- ksads_mdd_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(ksads_mdd_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(ksads_mdd_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: SOME RESIDUALS ARE VERY VERY LARGE
NOTE: THESE ARE EXTREMELY DIFFERENT
NOTE: HEAVILY SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zksads_mdd_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zksads_mdd_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zksads_mdd_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {eur ksads~prs and covar regressions - ptsd,r}

## ptsd ----
### Intercept-Only Model Estimation (for Y) ----
ksads_ptsd_M0 <- lmer(res_k_ptsd ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(ksads_ptsd_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # 0.3% of the variance in ptsd diagnoses is explained by site

### Random Intercept, Fixed Slopes without interactions ----
ksads_ptsd_M1a_gender <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                              gen_cmc_cisf + gen_cmc_gnc +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M1a_gender)
ksads_ptsd_M1a_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
ksads_ptsd_M1b_gender <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M1b_gender)
ksads_ptsd_M1b_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
ksads_ptsd_M2a_gender <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_ptsd_M2a_gender)
# sex failed to converge with either optimizer
ksads_ptsd_M2a_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_ptsd_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
ksads_ptsd_M2b_gender <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        gen_cmc_cisf + gen_cmc_gnc +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+gen_cmc_cisf|site)+(0+gen_cmc_gnc|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(ksads_ptsd_M2b_gender)
ksads_ptsd_M2b_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(ksads_ptsd_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# gender failed to converge with either optimizer
# ksads_ptsd_M2c_gender <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_ptsd_M2c_gender)
ksads_ptsd_M2c_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_ptsd_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# gender failed to converge with either optimizer
# ksads_ptsd_M2d_gender <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
#                         gen_cmc_cisf + gen_cmc_gnc +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs*gen_cmc_cisf + zcmc_prs*gen_cmc_gnc +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         gen_cmc_cisf + gen_cmc_gnc |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_ptsd_M2d_gender)
ksads_ptsd_M2d_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_ptsd_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(ksads_ptsd_M1a_sex,ksads_ptsd_M1b_sex,test="Chisq")  #1a is better
anova(ksads_ptsd_M1a_sex,ksads_ptsd_M2a_sex,test="Chisq") #1a is better
anova(ksads_ptsd_M1a_sex,ksads_ptsd_M2b_sex,test="Chisq") #1a is better
anova(ksads_ptsd_M1a_sex,ksads_ptsd_M2c_sex,test="Chisq") #1a is better
anova(ksads_ptsd_M1a_sex,ksads_ptsd_M2d_sex,test="Chisq") #1a is better

anova(ksads_ptsd_M1a_gender,ksads_ptsd_M1b_gender,test="Chisq")  #1a is better
anova(ksads_ptsd_M1a_gender,ksads_ptsd_M2a_gender,test="Chisq") #1a is better
anova(ksads_ptsd_M1a_gender,ksads_ptsd_M2b_gender,test="Chisq") #1a is better

# 1a gender: bic = 12560.6              
# 1a sex: bic = 12555.9                
# all: choose model 1a sex
eur_ksads_ptsd_M1a_gender <- ksads_ptsd_M1a_gender
eur_ksads_ptsd_M1a_sex <- ksads_ptsd_M1a_sex

### Sig Results ----
## cisf: p = 0.0000399     , beta = -0.34915                                    

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_k_ptsd) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(ksads_ptsd_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_ptsd <- 1 - res_var/orig_Y_var
R2_ptsd

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(ksads_ptsd_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(ksads_ptsd_M1a_sex)$coef), #predictor names
                          summary(ksads_ptsd_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$ksads_ptsd_M1a_sex_Yhat <- as.numeric(predict(ksads_ptsd_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_ptsd_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$ksads_ptsd_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$ksads_ptsd_M1a_sex_L1resid <- as.numeric(resid(ksads_ptsd_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_ptsd_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$ksads_ptsd_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(ksads_ptsd_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(ksads_ptsd_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zksads_ptsd_M1a_sex_Yhat,
           y=Zksads_ptsd_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
ksads_ptsd_M1a_sex_robustSE <- rlmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M1a_sex_robustSE)
summary(ksads_ptsd_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
eur_ksads_ptsd_M1a_sex_robustSE <- ksads_ptsd_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(ksads_ptsd_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(ksads_ptsd_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: SOME RESIDUALS ARE VERY VERY LARGE
NOTE: THESE ARE EXTREMELY DIFFERENT
NOTE: HEAVILY SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zksads_ptsd_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zksads_ptsd_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zksads_ptsd_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```




### Run regression for afr cbcl and ksads outcomes ~ PRS + income-to-needs + age + sex at yr4

``` {afr cbcl~prs and covar regressions - total,r}

## Total problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_total_M0 <- lmer(res_c_total ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_total_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_total_M1a_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_total_M1b_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_total_M2a_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_total_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_total_M2b_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_total_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_total_M2c_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_total_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_total_M2d_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_total_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_total_M1a_sex,cbcl_total_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_total_M1a_sex,cbcl_total_M2a_sex,test="Chisq") #1a is better
anova(cbcl_total_M1a_sex,cbcl_total_M2b_sex,test="Chisq") #1a is better
anova(cbcl_total_M1a_sex,cbcl_total_M2c_sex,test="Chisq") #1a is better
anova(cbcl_total_M1a_sex,cbcl_total_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 2480.7          
# all: choose model 1a sex
afr_cbcl_total_M1a_sex <- cbcl_total_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_total) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_total_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_total <- 1 - res_var/orig_Y_var
R2_total

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_total_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_total_M1a_sex)$coef), #predictor names
                          summary(cbcl_total_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_total))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_total_M1a_sex_Yhat <- as.numeric(predict(cbcl_total_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_total_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_total_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_total_M1a_sex_L1resid <- as.numeric(resid(cbcl_total_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_total_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_total_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_total_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_total_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_total_M1a_sex_Yhat,
           y=Zcbcl_total_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_total_M1a_sex_robustSE <- rlmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M1a_sex_robustSE)
summary(cbcl_total_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_cbcl_total_M1a_sex_robustSE <- cbcl_total_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_total_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_total_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_total_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_total_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_total_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {afr cbcl~prs and covar regressions - externalizing,r}

## Externalizing problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_ext_M0 <- lmer(res_c_ext ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_ext_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_ext_M1a_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_ext_M1b_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_ext_M2a_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_ext_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_ext_M2b_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_ext_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# sex failed to converge with either optimizer
# cbcl_ext_M2c_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_ext_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# cbcl_ext_M2d_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_ext_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_ext_M1a_sex,cbcl_ext_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_ext_M1a_sex,cbcl_ext_M2a_sex,test="Chisq") #1a is better
anova(cbcl_ext_M1a_sex,cbcl_ext_M2b_sex,test="Chisq") #1a is better

# 1a sex: bic = 2097.8        
# all: choose model 1a sex
afr_cbcl_ext_M1a_sex <- cbcl_ext_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_ext) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_ext_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_ext <- 1 - res_var/orig_Y_var
R2_ext

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_ext_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_ext_M1a_sex)$coef), #predictor names
                          summary(cbcl_ext_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_ext))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_ext_M1a_sex_Yhat <- as.numeric(predict(cbcl_ext_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_ext_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_ext_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_ext_M1a_sex_L1resid <- as.numeric(resid(cbcl_ext_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_ext_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_ext_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_ext_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_ext_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_ext_M1a_sex_Yhat,
           y=Zcbcl_ext_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_ext_M1a_sex_robustSE <- rlmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M1a_sex_robustSE)
summary(cbcl_ext_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_cbcl_ext_M1a_sex_robustSE <- cbcl_ext_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_ext_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_ext_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_ext_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_ext_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_ext_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {afr cbcl~prs and covar regressions - internalizing,r}

## Internalizing problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_int_M0 <- lmer(res_c_int ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_int_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_int_M1a_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_int_M1b_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_int_M2a_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_int_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_int_M2b_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_int_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_int_M2c_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_int_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_int_M2d_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_int_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_int_M1a_sex,cbcl_int_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_int_M1a_sex,cbcl_int_M2a_sex,test="Chisq") #1a is better
anova(cbcl_int_M1a_sex,cbcl_int_M2b_sex,test="Chisq") #1a is better
anova(cbcl_int_M1a_sex,cbcl_int_M2c_sex,test="Chisq") #1a is better
anova(cbcl_int_M1a_sex,cbcl_int_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 2672.3          
# all: choose model 1a sex
afr_cbcl_int_M1a_sex <- cbcl_int_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_int) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_int_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_int <- 1 - res_var/orig_Y_var
R2_int

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_int_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_int_M1a_sex)$coef), #predictor names
                          summary(cbcl_int_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_int))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_int_M1a_sex_Yhat <- as.numeric(predict(cbcl_int_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_int_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_int_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_int_M1a_sex_L1resid <- as.numeric(resid(cbcl_int_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_int_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_int_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_int_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_int_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_int_M1a_sex_Yhat,
           y=Zcbcl_int_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_int_M1a_sex_robustSE <- rlmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M1a_sex_robustSE)
summary(cbcl_int_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_cbcl_int_M1a_sex_robustSE <- cbcl_int_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_int_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_int_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_int_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_int_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_int_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {afr cbcl~prs and covar regressions - aggressive,r}

## Aggressive problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_aggress_M0 <- lmer(res_c_aggress ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_aggress_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in aggress problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_aggress_M1a_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_aggress_M1b_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_aggress_M2a_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_aggress_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_aggress_M2b_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_aggress_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_aggress_M2c_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_aggress_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# cbcl_aggress_M2d_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_aggress_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M2a_sex,test="Chisq") #1a is better
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M2b_sex,test="Chisq") #1a is better
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M2c_sex,test="Chisq") #1a is better

# 1a sex: bic = 947.0           
# all: choose model 1a sex
afr_cbcl_aggress_M1a_sex <- cbcl_aggress_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_aggress) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_aggress_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_aggress <- 1 - res_var/orig_Y_var
R2_aggress

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_aggress_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_aggress_M1a_sex)$coef), #predictor names
                          summary(cbcl_aggress_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_aggress))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_aggress_M1a_sex_Yhat <- as.numeric(predict(cbcl_aggress_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_aggress_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_aggress_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_aggress_M1a_sex_L1resid <- as.numeric(resid(cbcl_aggress_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_aggress_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_aggress_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_aggress_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_aggress_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_aggress_M1a_sex_Yhat,
           y=Zcbcl_aggress_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_aggress_M1a_sex_robustSE <- rlmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M1a_sex_robustSE)
summary(cbcl_aggress_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_cbcl_aggress_M1a_sex_robustSE <- cbcl_aggress_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_aggress_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_aggress_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_aggress_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_aggress_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_aggress_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {afr cbcl~prs and covar regressions - attention,r}

## Attention problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_attn_M0 <- lmer(res_c_attn ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_attn_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_attn_M1a_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_attn_M1b_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_attn_M2a_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_attn_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_attn_M2b_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_attn_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_attn_M2c_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_attn_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_attn_M2d_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_attn_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_attn_M1a_sex,cbcl_attn_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2a_sex,test="Chisq") #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2b_sex,test="Chisq") #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2c_sex,test="Chisq") #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = -291.9        
# all: choose model 1a sex
afr_cbcl_attn_M1a_sex <- cbcl_attn_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_attn) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_attn_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_attn <- 1 - res_var/orig_Y_var
R2_attn

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_attn_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_attn_M1a_sex)$coef), #predictor names
                          summary(cbcl_attn_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_attn))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_attn_M1a_sex_Yhat <- as.numeric(predict(cbcl_attn_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_attn_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_attn_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_attn_M1a_sex_L1resid <- as.numeric(resid(cbcl_attn_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_attn_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_attn_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_attn_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_attn_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_attn_M1a_sex_Yhat,
           y=Zcbcl_attn_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_attn_M1a_sex_robustSE <- rlmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M1a_sex_robustSE)
summary(cbcl_attn_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_cbcl_attn_M1a_sex_robustSE <- cbcl_attn_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_attn_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_attn_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_attn_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_attn_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_attn_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {afr cbcl~prs and covar regressions - anxious/depressed,r}

## Anxious/depressed problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_anxdep_M0 <- lmer(res_c_anxdep ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_anxdep_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_anxdep_M1a_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_anxdep_M1b_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_anxdep_M2a_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_anxdep_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_anxdep_M2b_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_anxdep_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_anxdep_M2c_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_anxdep_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# cbcl_anxdep_M2d_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_anxdep_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M2a_sex,test="Chisq") #1a is better
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M2b_sex,test="Chisq") #1a is better
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M2c_sex,test="Chisq") #1a is better

# 1a sex: bic = 1553.9           
# all: choose model 1a sex
afr_cbcl_anxdep_M1a_sex <- cbcl_anxdep_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_anxdep) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_anxdep_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_anxdep <- 1 - res_var/orig_Y_var
R2_anxdep

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_anxdep_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_anxdep_M1a_sex)$coef), #predictor names
                          summary(cbcl_anxdep_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_anxdep))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_anxdep_M1a_sex_Yhat <- as.numeric(predict(cbcl_anxdep_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_anxdep_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_anxdep_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_anxdep_M1a_sex_L1resid <- as.numeric(resid(cbcl_anxdep_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_anxdep_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_anxdep_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_anxdep_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_anxdep_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_anxdep_M1a_sex_Yhat,
           y=Zcbcl_anxdep_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_anxdep_M1a_sex_robustSE <- rlmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M1a_sex_robustSE)
summary(cbcl_anxdep_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_cbcl_anxdep_M1a_sex_robustSE <- cbcl_anxdep_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_anxdep_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_anxdep_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_anxdep_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_anxdep_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_anxdep_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {afr cbcl~prs and covar regressions - withdrawn/depressed,r}

## Withdrawn/depressed problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_withdep_M0 <- lmer(res_c_withdep ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_withdep_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_withdep_M1a_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_withdep_M1b_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_withdep_M2a_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_withdep_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_withdep_M2b_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_withdep_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_withdep_M2c_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_withdep_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_withdep_M2d_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_withdep_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M2a_sex,test="Chisq") #1a is better
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M2b_sex,test="Chisq") #1a is better
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M2c_sex,test="Chisq") #1a is better
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 482.9              
# all: choose model 1a sex
afr_cbcl_withdep_M1a_sex <- cbcl_withdep_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_withdep) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_withdep_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_withdep <- 1 - res_var/orig_Y_var
R2_withdep

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_withdep_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_withdep_M1a_sex)$coef), #predictor names
                          summary(cbcl_withdep_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_withdep))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_withdep_M1a_sex_Yhat <- as.numeric(predict(cbcl_withdep_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_withdep_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_withdep_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_withdep_M1a_sex_L1resid <- as.numeric(resid(cbcl_withdep_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_withdep_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_withdep_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_withdep_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_withdep_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_withdep_M1a_sex_Yhat,
           y=Zcbcl_withdep_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_withdep_M1a_sex_robustSE <- rlmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M1a_sex_robustSE)
summary(cbcl_withdep_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_cbcl_withdep_M1a_sex_robustSE <- cbcl_withdep_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_withdep_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_withdep_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_withdep_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_withdep_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_withdep_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {afr cbcl~prs and covar regressions - rulebreaking,r}

## Rule-breaking problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_rule_M0 <- lmer(res_c_rule ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_rule_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_rule_M1a_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_rule_M1b_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_rule_M2a_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_rule_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_rule_M2b_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_rule_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_rule_M2c_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_rule_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_rule_M2d_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_rule_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_rule_M1a_sex,cbcl_rule_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2a_sex,test="Chisq") #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2b_sex,test="Chisq") #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2c_sex,test="Chisq") #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = -777.2                  
# all: choose model 1a sex
afr_cbcl_rule_M1a_sex <- cbcl_rule_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_rule) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_rule_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_rule <- 1 - res_var/orig_Y_var
R2_rule

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_rule_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_rule_M1a_sex)$coef), #predictor names
                          summary(cbcl_rule_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_rule))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_rule_M1a_sex_Yhat <- as.numeric(predict(cbcl_rule_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_rule_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_rule_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_rule_M1a_sex_L1resid <- as.numeric(resid(cbcl_rule_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_rule_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_rule_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_rule_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_rule_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_rule_M1a_sex_Yhat,
           y=Zcbcl_rule_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_rule_M1a_sex_robustSE <- rlmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M1a_sex_robustSE)
summary(cbcl_rule_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_cbcl_rule_M1a_sex_robustSE <- cbcl_rule_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_rule_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_rule_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_rule_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_rule_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_rule_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {afr cbcl~prs and covar regressions - social,r}

## Social problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_social_M0 <- lmer(res_c_social ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_social_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_social_M1a_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_social_M1b_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_social_M2a_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_social_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_social_M2b_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_social_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# sex failed to converge with either optimizer
# cbcl_social_M2c_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_social_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# cbcl_social_M2d_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_social_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_social_M1a_sex,cbcl_social_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_social_M1a_sex,cbcl_social_M2a_sex,test="Chisq") #1a is better
anova(cbcl_social_M1a_sex,cbcl_social_M2b_sex,test="Chisq") #1a is better

# 1a sex: bic = 986.2                     
# all: choose model 1a sex
afr_cbcl_social_M1a_sex <- cbcl_social_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_social) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_social_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_social <- 1 - res_var/orig_Y_var
R2_social

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_social_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_social_M1a_sex)$coef), #predictor names
                          summary(cbcl_social_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_social))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_social_M1a_sex_Yhat <- as.numeric(predict(cbcl_social_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_social_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_social_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_social_M1a_sex_L1resid <- as.numeric(resid(cbcl_social_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_social_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_social_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_social_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_social_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_social_M1a_sex_Yhat,
           y=Zcbcl_social_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_social_M1a_sex_robustSE <- rlmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M1a_sex_robustSE)
summary(cbcl_social_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_cbcl_social_M1a_sex_robustSE <- cbcl_social_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_social_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_social_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_social_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_social_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_social_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {afr cbcl~prs and covar regressions - somatic,r}

## Somatic problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_somatic_M0 <- lmer(res_c_somatic ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_somatic_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_somatic_M1a_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_somatic_M1b_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_somatic_M2a_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_somatic_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_somatic_M2b_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_somatic_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# sex failed to converge with either optimizer
# cbcl_somatic_M2c_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_somatic_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_somatic_M2d_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_somatic_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M2a_sex,test="Chisq") #1a is better
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M2b_sex,test="Chisq") #1a is better
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 1120.0                     
# all: choose model 1a sex
afr_cbcl_somatic_M1a_sex <- cbcl_somatic_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_somatic) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_somatic_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_somatic <- 1 - res_var/orig_Y_var
R2_somatic

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_somatic_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_somatic_M1a_sex)$coef), #predictor names
                          summary(cbcl_somatic_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_somatic))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_somatic_M1a_sex_Yhat <- as.numeric(predict(cbcl_somatic_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_somatic_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_somatic_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_somatic_M1a_sex_L1resid <- as.numeric(resid(cbcl_somatic_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_somatic_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_somatic_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_somatic_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_somatic_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_somatic_M1a_sex_Yhat,
           y=Zcbcl_somatic_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_somatic_M1a_sex_robustSE <- rlmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M1a_sex_robustSE)
summary(cbcl_somatic_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_cbcl_somatic_M1a_sex_robustSE <- cbcl_somatic_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_somatic_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_somatic_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_somatic_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_somatic_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_somatic_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {afr cbcl~prs and covar regressions - thought,r}

## Thought problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_thought_M0 <- lmer(res_c_thought ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_thought_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_thought_M1a_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_thought_M1b_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M1b_sex)

# ggplot(aes(x=zcmc_prs,y=res_c_thought),data=yr4_reg_data) +
ggplot(aes(x=zcmc_prs,y=raw_c_thought),data=yr4_reg_data) +
  geom_point() +
  geom_smooth(method="lm") +
  labs(x="PRS (Z Score)",y="Thought Problems",title="African Ancestry") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) 


### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_thought_M2a_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_thought_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_thought_M2b_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_thought_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_thought_M2c_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_thought_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# cbcl_thought_M2d_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_thought_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_thought_M1a_sex,cbcl_thought_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_thought_M1a_sex,cbcl_thought_M2a_sex,test="Chisq") #1a is better
anova(cbcl_thought_M1a_sex,cbcl_thought_M2b_sex,test="Chisq") #1a is better
anova(cbcl_thought_M1a_sex,cbcl_thought_M2c_sex,test="Chisq") #1a is better

# 1a sex: bic = 1648.9                        
# all: choose model 1a sex
afr_cbcl_thought_M1a_sex <- cbcl_thought_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_thought) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_thought_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_thought <- 1 - res_var/orig_Y_var
R2_thought

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_thought_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_thought_M1a_sex)$coef), #predictor names
                          summary(cbcl_thought_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_thought_M1a_sex_Yhat <- as.numeric(predict(cbcl_thought_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_thought_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_thought_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_thought_M1a_sex_L1resid <- as.numeric(resid(cbcl_thought_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_thought_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_thought_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_thought_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_thought_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_thought_M1a_sex_Yhat,
           y=Zcbcl_thought_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_thought_M1a_sex_robustSE <- rlmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M1a_sex_robustSE)
summary(cbcl_thought_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_cbcl_thought_M1a_sex_robustSE <- cbcl_thought_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_thought_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_thought_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_thought_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_thought_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_thought_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {afr ksads~prs and covar regressions - gad,r}

## GAD ----
### Intercept-Only Model Estimation (for Y) ----
ksads_gad_M0 <- lmer(res_k_gad ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(ksads_gad_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(ksads_gad_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in gad diagnoses is explained by site

### Random Intercept, Fixed Slopes without interactions ----
ksads_gad_M1a_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_gad_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
ksads_gad_M1b_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(ksads_gad_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
ksads_gad_M2a_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_gad_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
ksads_gad_M2b_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(ksads_gad_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
ksads_gad_M2c_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_gad_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
ksads_gad_M2d_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_gad_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(ksads_gad_M1a_sex,ksads_gad_M1b_sex,test="Chisq")  #1a is better
anova(ksads_gad_M1a_sex,ksads_gad_M2a_sex,test="Chisq") #1a is better
anova(ksads_gad_M1a_sex,ksads_gad_M2b_sex,test="Chisq") #1a is better
anova(ksads_gad_M1a_sex,ksads_gad_M2c_sex,test="Chisq") #1a is better
anova(ksads_gad_M1a_sex,ksads_gad_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 2701.6              
# all: choose model 1a sex
afr_ksads_gad_M1a_sex <- ksads_gad_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_k_gad) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(ksads_gad_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_gad <- 1 - res_var/orig_Y_var
R2_gad

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(ksads_gad_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(ksads_gad_M1a_sex)$coef), #predictor names
                          summary(ksads_gad_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$ksads_gad_M1a_sex_Yhat <- as.numeric(predict(ksads_gad_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_gad_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$ksads_gad_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$ksads_gad_M1a_sex_L1resid <- as.numeric(resid(ksads_gad_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_gad_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$ksads_gad_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(ksads_gad_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(ksads_gad_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zksads_gad_M1a_sex_Yhat,
           y=Zksads_gad_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
ksads_gad_M1a_sex_robustSE <- rlmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_gad_M1a_sex_robustSE)
summary(ksads_gad_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_ksads_gad_M1a_sex_robustSE <- ksads_gad_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(ksads_gad_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(ksads_gad_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: SOME RESIDUALS ARE VERY VERY LARGE
NOTE: THESE ARE EXTREMELY DIFFERENT
NOTE: HEAVILY SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zksads_gad_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zksads_gad_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zksads_gad_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {afr ksads~prs and covar regressions - mdd,r}

## MDD ----
### Intercept-Only Model Estimation (for Y) ----
ksads_mdd_M0 <- lmer(res_k_mdd ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(ksads_mdd_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in mdd diagnoses is explained by site

### Random Intercept, Fixed Slopes without interactions ----
ksads_mdd_M1a_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
ksads_mdd_M1b_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
ksads_mdd_M2a_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_mdd_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
ksads_mdd_M2b_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(ksads_mdd_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
ksads_mdd_M2c_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_mdd_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# ksads_mdd_M2d_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_mdd_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(ksads_mdd_M1a_sex,ksads_mdd_M1b_sex,test="Chisq")  #1a is better
anova(ksads_mdd_M1a_sex,ksads_mdd_M2a_sex,test="Chisq") #1a is better
anova(ksads_mdd_M1a_sex,ksads_mdd_M2b_sex,test="Chisq") #1a is better
anova(ksads_mdd_M1a_sex,ksads_mdd_M2c_sex,test="Chisq") #2c is better

# 2c sex: bic = 2383.5                
# all: choose model 2c sex
afr_ksads_mdd_M2c_sex <- ksads_mdd_M2c_sex

### Sig Results ----
## no sig results                


### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_k_mdd) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(ksads_mdd_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_mdd <- 1 - res_var/orig_Y_var
R2_mdd

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(ksads_mdd_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(ksads_mdd_M1a_sex)$coef), #predictor names
                          summary(ksads_mdd_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$ksads_mdd_M1a_sex_Yhat <- as.numeric(predict(ksads_mdd_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_mdd_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$ksads_mdd_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$ksads_mdd_M1a_sex_L1resid <- as.numeric(resid(ksads_mdd_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_mdd_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$ksads_mdd_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(ksads_mdd_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(ksads_mdd_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zksads_mdd_M1a_sex_Yhat,
           y=Zksads_mdd_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
ksads_mdd_M1a_sex_robustSE <- rlmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M1a_sex_robustSE)
summary(ksads_mdd_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_ksads_mdd_M1a_sex_robustSE <- ksads_mdd_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(ksads_mdd_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(ksads_mdd_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: SOME RESIDUALS ARE VERY VERY LARGE
NOTE: THESE ARE EXTREMELY DIFFERENT
NOTE: HEAVILY SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zksads_mdd_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zksads_mdd_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zksads_mdd_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {afr ksads~prs and covar regressions - ptsd,r}

## PTSD ----
### Intercept-Only Model Estimation (for Y) ----
ksads_ptsd_M0 <- lmer(res_k_ptsd ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(ksads_ptsd_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ptsd diagnoses is explained by site

### Random Intercept, Fixed Slopes without interactions ----
ksads_ptsd_M1a_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
ksads_ptsd_M1b_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M1b_sex)

# ggplot(aes(x=zcmc_prs,y=res_c_thought),data=yr4_reg_data) +
ggplot(aes(x=zcmc_prs,y=zcmc_income),data=yr4_reg_data[which(yr4_reg_data$raw_k_ptsd==0),]) +
  geom_point() +
  geom_smooth(method="lm") +
  labs(x="PRS (Z Score)",y="Income-to-Needs Ratio (Z Score)",title="No PTSD (African Ancestry)") +
  xlim(-6.1,7.1) +
  ylim(-1.75,3.4) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) 
# ggplot(aes(x=zcmc_prs,y=res_c_thought),data=yr4_reg_data) +
ggplot(aes(x=zcmc_prs,y=zcmc_income),data=yr4_reg_data[which(yr4_reg_data$raw_k_ptsd==1),]) +
  geom_point() +
  geom_smooth(method="lm") +
  labs(x="PRS (Z Score)",y="Income-to-Needs Ratio (Z Score)",title="PTSD (African Ancestry)") +
  xlim(-6.1,7.1) +
  ylim(-1.75,3.4) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) 

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
ksads_ptsd_M2a_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_ptsd_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
ksads_ptsd_M2b_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(ksads_ptsd_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
ksads_ptsd_M2c_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_ptsd_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# ksads_ptsd_M2d_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_ptsd_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(ksads_ptsd_M1a_sex,ksads_ptsd_M1b_sex,test="Chisq")  #1b is better
anova(ksads_ptsd_M1b_sex,ksads_ptsd_M2a_sex,test="Chisq") #1b is better
anova(ksads_ptsd_M1b_sex,ksads_ptsd_M2b_sex,test="Chisq") #2b is better
anova(ksads_ptsd_M2b_sex,ksads_ptsd_M2c_sex,test="Chisq") #2b is better

# 2b sex: bic = 4124.5                  
# all: choose model 2c sex
afr_ksads_ptsd_M2b_sex <- ksads_ptsd_M2b_sex

### Sig Results ----
## cisf: p = 0.041523, beta = 1.3469  
## prs*cisf: p = 0.000282, beta = 1.0284     

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(dataframe$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_k_ptsd) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(ksads_ptsd_M2b_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_ptsd <- 1 - res_var/orig_Y_var
R2_ptsd

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(ksads_ptsd_M2b_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(ksads_ptsd_M2b_sex)$coef), #predictor names
                          summary(ksads_ptsd_M2b_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$ksads_ptsd_M1a_sex_Yhat <- as.numeric(predict(ksads_ptsd_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_ptsd_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$ksads_ptsd_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$ksads_ptsd_M1a_sex_L1resid <- as.numeric(resid(ksads_ptsd_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_ptsd_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$ksads_ptsd_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(ksads_ptsd_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(ksads_ptsd_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zksads_ptsd_M1a_sex_Yhat,
           y=Zksads_ptsd_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
ksads_ptsd_M1a_sex_robustSE <- rlmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M1a_sex_robustSE)
summary(ksads_ptsd_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
afr_ksads_ptsd_M1a_sex_robustSE <- ksads_ptsd_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(ksads_ptsd_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(ksads_ptsd_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: SOME RESIDUALS ARE VERY VERY LARGE
NOTE: THESE ARE EXTREMELY DIFFERENT
NOTE: HEAVILY SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zksads_ptsd_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zksads_ptsd_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zksads_ptsd_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```



### Run regression for amadmix cbcl and ksads outcomes ~ PRS + income-to-needs + age + sex at yr4

``` {amadmix cbcl~prs and covar regressions - total,r}

## Total problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_total_M0 <- lmer(res_c_total ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_total_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_total_M1a_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_total_M1b_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_total_M2a_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_total_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_total_M2b_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_total_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# sex failed to converge with either optimizer
# cbcl_total_M2c_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_total_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_total_M2d_sex <- lmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_total_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_total_M1a_sex,cbcl_total_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_total_M1a_sex,cbcl_total_M2a_sex,test="Chisq") #1a is better
anova(cbcl_total_M1a_sex,cbcl_total_M2b_sex,test="Chisq") #1a is better
anova(cbcl_total_M1a_sex,cbcl_total_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 2285.5            
# all: choose model 1a sex
amadmix_cbcl_total_M1a_sex <- cbcl_total_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_total) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_total_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_total <- 1 - res_var/orig_Y_var
R2_total

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_total_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_total_M1a_sex)$coef), #predictor names
                          summary(cbcl_total_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_total))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_total_M1a_sex_Yhat <- as.numeric(predict(cbcl_total_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_total_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_total_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_total_M1a_sex_L1resid <- as.numeric(resid(cbcl_total_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_total_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_total_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_total_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_total_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_total_M1a_sex_Yhat,
           y=Zcbcl_total_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_total_M1a_sex_robustSE <- rlmer(res_c_total ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_total_M1a_sex_robustSE)
summary(cbcl_total_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_cbcl_total_M1a_sex_robustSE <- cbcl_total_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_total_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_total_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_total_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_total_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_total_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {amadmix cbcl~prs and covar regressions - externalizing,r}

## Externalizing problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_ext_M0 <- lmer(res_c_ext ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_ext_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_ext_M1a_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_ext_M1b_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_ext_M2a_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_ext_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_ext_M2b_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_ext_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_ext_M2c_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_ext_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_ext_M2d_sex <- lmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_ext_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_ext_M1a_sex,cbcl_ext_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_ext_M1a_sex,cbcl_ext_M2a_sex,test="Chisq") #1a is better
anova(cbcl_ext_M1a_sex,cbcl_ext_M2b_sex,test="Chisq") #1a is better
anova(cbcl_ext_M1a_sex,cbcl_ext_M2c_sex,test="Chisq") #1a is better
anova(cbcl_ext_M1a_sex,cbcl_ext_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 1491.4           
# all: choose model 1a sex
amadmix_cbcl_ext_M1a_sex <- cbcl_ext_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_ext) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_ext_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_ext <- 1 - res_var/orig_Y_var
R2_ext

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_ext_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_ext_M1a_sex)$coef), #predictor names
                          summary(cbcl_ext_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_ext))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_ext_M1a_sex_Yhat <- as.numeric(predict(cbcl_ext_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_ext_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_ext_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_ext_M1a_sex_L1resid <- as.numeric(resid(cbcl_ext_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_ext_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_ext_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_ext_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_ext_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_ext_M1a_sex_Yhat,
           y=Zcbcl_ext_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_ext_M1a_sex_robustSE <- rlmer(res_c_ext ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_ext_M1a_sex_robustSE)
summary(cbcl_ext_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_cbcl_ext_M1a_sex_robustSE <- cbcl_ext_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_ext_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_ext_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_ext_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_ext_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_ext_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {amadmix cbcl~prs and covar regressions - internalizing,r}

## Internalizing problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_int_M0 <- lmer(res_c_int ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_int_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_int_M1a_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_int_M1b_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_int_M2a_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_int_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_int_M2b_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_int_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_int_M2c_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_int_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# cbcl_int_M2d_sex <- lmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_int_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_int_M1a_sex,cbcl_int_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_int_M1a_sex,cbcl_int_M2a_sex,test="Chisq") #1a is better
anova(cbcl_int_M1a_sex,cbcl_int_M2b_sex,test="Chisq") #1a is better
anova(cbcl_int_M1a_sex,cbcl_int_M2c_sex,test="Chisq") #1a is better

# 1a sex: bic = 2475.7            
# all: choose model 1a sex
amadmix_cbcl_int_M1a_sex <- cbcl_int_M1a_sex

### Sig Results ----
## cisf: p = 0.00404  , beta = 0.43547                    

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_int) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_int_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_int <- 1 - res_var/orig_Y_var
R2_int

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_int_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_int_M1a_sex)$coef), #predictor names
                          summary(cbcl_int_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_int))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_int_M1a_sex_Yhat <- as.numeric(predict(cbcl_int_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_int_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_int_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_int_M1a_sex_L1resid <- as.numeric(resid(cbcl_int_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_int_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_int_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_int_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_int_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_int_M1a_sex_Yhat,
           y=Zcbcl_int_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_int_M1a_sex_robustSE <- rlmer(res_c_int ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_int_M1a_sex_robustSE)
summary(cbcl_int_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_cbcl_int_M1a_sex_robustSE <- cbcl_int_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_int_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_int_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_int_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_int_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_int_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {amadmix cbcl~prs and covar regressions - aggressive,r}

## Aggressive problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_aggress_M0 <- lmer(res_c_aggress ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_aggress_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in aggress problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_aggress_M1a_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_aggress_M1b_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_aggress_M2a_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_aggress_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_aggress_M2b_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_aggress_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# sex failed to converge with either optimizer
# cbcl_aggress_M2c_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_aggress_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_aggress_M2d_sex <- lmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_aggress_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M2a_sex,test="Chisq") #1a is better
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M2b_sex,test="Chisq") #1a is better
anova(cbcl_aggress_M1a_sex,cbcl_aggress_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 2343.5             
# all: choose model 1a sex
amadmix_cbcl_aggress_M1a_sex <- cbcl_aggress_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_aggress) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_aggress_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_aggress <- 1 - res_var/orig_Y_var
R2_aggress

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_aggress_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_aggress_M1a_sex)$coef), #predictor names
                          summary(cbcl_aggress_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_aggress))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_aggress_M1a_sex_Yhat <- as.numeric(predict(cbcl_aggress_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_aggress_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_aggress_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_aggress_M1a_sex_L1resid <- as.numeric(resid(cbcl_aggress_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_aggress_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_aggress_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_aggress_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_aggress_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_aggress_M1a_sex_Yhat,
           y=Zcbcl_aggress_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_aggress_M1a_sex_robustSE <- rlmer(res_c_aggress ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_aggress_M1a_sex_robustSE)
summary(cbcl_aggress_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_cbcl_aggress_M1a_sex_robustSE <- cbcl_aggress_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_aggress_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_aggress_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_aggress_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_aggress_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_aggress_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {amadmix cbcl~prs and covar regressions - attention,r}

## Attention problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_attn_M0 <- lmer(res_c_attn ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_attn_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_attn_M1a_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_attn_M1b_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_attn_M2a_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_attn_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_attn_M2b_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_attn_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_attn_M2c_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_attn_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_attn_M2d_sex <- lmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_attn_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_attn_M1a_sex,cbcl_attn_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2a_sex,test="Chisq") #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2b_sex,test="Chisq") #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2c_sex,test="Chisq") #1a is better
anova(cbcl_attn_M1a_sex,cbcl_attn_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 828.1           
# all: choose model 1a sex
amadmix_cbcl_attn_M1a_sex <- cbcl_attn_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_attn) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_attn_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_attn <- 1 - res_var/orig_Y_var
R2_attn

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_attn_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_attn_M1a_sex)$coef), #predictor names
                          summary(cbcl_attn_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_attn))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_attn_M1a_sex_Yhat <- as.numeric(predict(cbcl_attn_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_attn_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_attn_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_attn_M1a_sex_L1resid <- as.numeric(resid(cbcl_attn_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_attn_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_attn_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_attn_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_attn_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_attn_M1a_sex_Yhat,
           y=Zcbcl_attn_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_attn_M1a_sex_robustSE <- rlmer(res_c_attn ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_attn_M1a_sex_robustSE)
summary(cbcl_attn_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_cbcl_attn_M1a_sex_robustSE <- cbcl_attn_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_attn_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_attn_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_attn_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_attn_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_attn_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {amadmix cbcl~prs and covar regressions - anxious/depressed,r}

## Anxious/depressed problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_anxdep_M0 <- lmer(res_c_anxdep ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_anxdep_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_anxdep_M1a_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_anxdep_M1b_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_anxdep_M2a_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_anxdep_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_anxdep_M2b_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_anxdep_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_anxdep_M2c_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_anxdep_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_anxdep_M2d_sex <- lmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_anxdep_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M2a_sex,test="Chisq") #1a is better
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M2b_sex,test="Chisq") #1a is better
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M2c_sex,test="Chisq") #1a is better
anova(cbcl_anxdep_M1a_sex,cbcl_anxdep_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 2499.9             
# all: choose model 1a sex
amadmix_cbcl_anxdep_M1a_sex <- cbcl_anxdep_M1a_sex

### Sig Results ----
## cisf: p = 0.00577   , beta = 0.42884                        

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_anxdep) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_anxdep_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_anxdep <- 1 - res_var/orig_Y_var
R2_anxdep

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_anxdep_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_anxdep_M1a_sex)$coef), #predictor names
                          summary(cbcl_anxdep_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_anxdep))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_anxdep_M1a_sex_Yhat <- as.numeric(predict(cbcl_anxdep_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_anxdep_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_anxdep_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_anxdep_M1a_sex_L1resid <- as.numeric(resid(cbcl_anxdep_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_anxdep_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_anxdep_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_anxdep_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_anxdep_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_anxdep_M1a_sex_Yhat,
           y=Zcbcl_anxdep_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_anxdep_M1a_sex_robustSE <- rlmer(res_c_anxdep ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_anxdep_M1a_sex_robustSE)
summary(cbcl_anxdep_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_cbcl_anxdep_M1a_sex_robustSE <- cbcl_anxdep_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_anxdep_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_anxdep_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_anxdep_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_anxdep_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_anxdep_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {amadmix cbcl~prs and covar regressions - withdrawn/depressed,r}

## Withdrawn/depressed problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_withdep_M0 <- lmer(res_c_withdep ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_withdep_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_withdep_M1a_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_withdep_M1b_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_withdep_M2a_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_withdep_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_withdep_M2b_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_withdep_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_withdep_M2c_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_withdep_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# cbcl_withdep_M2d_sex <- lmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_withdep_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M2a_sex,test="Chisq") #1a is better
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M2b_sex,test="Chisq") #1a is better
anova(cbcl_withdep_M1a_sex,cbcl_withdep_M2c_sex,test="Chisq") #1a is better

# 1a sex: bic = 2502.0                
# all: choose model 1a sex
amadmix_cbcl_withdep_M1a_sex <- cbcl_withdep_M1a_sex

### Sig Results ----
## cisf: p = 0.0159   , beta = 0.375182                       

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_withdep) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_withdep_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_withdep <- 1 - res_var/orig_Y_var
R2_withdep

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_withdep_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_withdep_M1a_sex)$coef), #predictor names
                          summary(cbcl_withdep_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_withdep))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_withdep_M1a_sex_Yhat <- as.numeric(predict(cbcl_withdep_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_withdep_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_withdep_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_withdep_M1a_sex_L1resid <- as.numeric(resid(cbcl_withdep_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_withdep_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_withdep_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_withdep_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_withdep_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_withdep_M1a_sex_Yhat,
           y=Zcbcl_withdep_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_withdep_M1a_sex_robustSE <- rlmer(res_c_withdep ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_withdep_M1a_sex_robustSE)
summary(cbcl_withdep_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_cbcl_withdep_M1a_sex_robustSE <- cbcl_withdep_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_withdep_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_withdep_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_withdep_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_withdep_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_withdep_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {amadmix cbcl~prs and covar regressions - rulebreaking,r}

## Rule-breaking problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_rule_M0 <- lmer(res_c_rule ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_rule_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_rule_M1a_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_rule_M1b_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_rule_M2a_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_rule_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_rule_M2b_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_rule_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_rule_M2c_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_rule_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_rule_M2d_sex <- lmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_rule_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_rule_M1a_sex,cbcl_rule_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2a_sex,test="Chisq") #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2b_sex,test="Chisq") #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2c_sex,test="Chisq") #1a is better
anova(cbcl_rule_M1a_sex,cbcl_rule_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 1730.3                     
# all: choose model 1a sex
amadmix_cbcl_rule_M1a_sex <- cbcl_rule_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_rule) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_rule_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_rule <- 1 - res_var/orig_Y_var
R2_rule

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_rule_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_rule_M1a_sex)$coef), #predictor names
                          summary(cbcl_rule_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_rule))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_rule_M1a_sex_Yhat <- as.numeric(predict(cbcl_rule_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_rule_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_rule_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_rule_M1a_sex_L1resid <- as.numeric(resid(cbcl_rule_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_rule_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_rule_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_rule_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_rule_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_rule_M1a_sex_Yhat,
           y=Zcbcl_rule_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_rule_M1a_sex_robustSE <- rlmer(res_c_rule ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_rule_M1a_sex_robustSE)
summary(cbcl_rule_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_cbcl_rule_M1a_sex_robustSE <- cbcl_rule_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_rule_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_rule_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_rule_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_rule_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_rule_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {amadmix cbcl~prs and covar regressions - social,r}

## Social problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_social_M0 <- lmer(res_c_social ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_social_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_social_M1a_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_social_M1b_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_social_M2a_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_social_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_social_M2b_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                         
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_social_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_social_M2c_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_social_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# cbcl_social_M2d_sex <- lmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_social_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_social_M1a_sex,cbcl_social_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_social_M1a_sex,cbcl_social_M2a_sex,test="Chisq") #1a is better
anova(cbcl_social_M1a_sex,cbcl_social_M2b_sex,test="Chisq") #1a is better
anova(cbcl_social_M1a_sex,cbcl_social_M2c_sex,test="Chisq") #1a is better

# 1a sex: bic = 1967.4                        
# all: choose model 1a sex
amadmix_cbcl_social_M1a_sex <- cbcl_social_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_social) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_social_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_social <- 1 - res_var/orig_Y_var
R2_social

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_social_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_social_M1a_sex)$coef), #predictor names
                          summary(cbcl_social_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_social))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_social_M1a_sex_Yhat <- as.numeric(predict(cbcl_social_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_social_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_social_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_social_M1a_sex_L1resid <- as.numeric(resid(cbcl_social_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_social_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_social_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_social_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_social_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_social_M1a_sex_Yhat,
           y=Zcbcl_social_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_social_M1a_sex_robustSE <- rlmer(res_c_social ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_social_M1a_sex_robustSE)
summary(cbcl_social_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_cbcl_social_M1a_sex_robustSE <- cbcl_social_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_social_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_social_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: THESE ARE PRETTY DIFFERENT
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_social_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_social_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_social_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {amadmix cbcl~prs and covar regressions - somatic,r}

## Somatic problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_somatic_M0 <- lmer(res_c_somatic ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_somatic_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_somatic_M1a_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_somatic_M1b_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_somatic_M2a_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_somatic_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_somatic_M2b_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_somatic_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_somatic_M2c_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_somatic_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
cbcl_somatic_M2d_sex <- lmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_somatic_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M2a_sex,test="Chisq") #1a is better
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M2b_sex,test="Chisq") #1a is better
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M2c_sex,test="Chisq") #1a is better
anova(cbcl_somatic_M1a_sex,cbcl_somatic_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 1535.4                        
# all: choose model 1a sex
amadmix_cbcl_somatic_M1a_sex <- cbcl_somatic_M1a_sex

### Sig Results ----
## cisf: p = 0.00763   , beta = 0.14917                        

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_somatic) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_somatic_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_somatic <- 1 - res_var/orig_Y_var
R2_somatic

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_somatic_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_somatic_M1a_sex)$coef), #predictor names
                          summary(cbcl_somatic_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_somatic))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_somatic_M1a_sex_Yhat <- as.numeric(predict(cbcl_somatic_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_somatic_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_somatic_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_somatic_M1a_sex_L1resid <- as.numeric(resid(cbcl_somatic_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_somatic_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_somatic_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_somatic_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_somatic_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_somatic_M1a_sex_Yhat,
           y=Zcbcl_somatic_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_somatic_M1a_sex_robustSE <- rlmer(res_c_somatic ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_somatic_M1a_sex_robustSE)
summary(cbcl_somatic_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_cbcl_somatic_M1a_sex_robustSE <- cbcl_somatic_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_somatic_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_somatic_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_somatic_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_somatic_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_somatic_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {amadmix cbcl~prs and covar regressions - thought,r}

## Thought problems score ----
### Intercept-Only Model Estimation (for Y) ----
cbcl_thought_M0 <- lmer(res_c_thought ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(cbcl_thought_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ext problems is explained by site

### Random Intercept, Fixed Slopes without interactions ----
cbcl_thought_M1a_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
cbcl_thought_M1b_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
cbcl_thought_M2a_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(cbcl_thought_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
cbcl_thought_M2b_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site), 
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_thought_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
cbcl_thought_M2c_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(cbcl_thought_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# cbcl_thought_M2d_sex <- lmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs* zcmc_prs*
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf|site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(cbcl_thought_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(cbcl_thought_M1a_sex,cbcl_thought_M1b_sex,test="Chisq")  #1a is better
anova(cbcl_thought_M1a_sex,cbcl_thought_M2a_sex,test="Chisq") #1a is better
anova(cbcl_thought_M1a_sex,cbcl_thought_M2b_sex,test="Chisq") #1a is better
anova(cbcl_thought_M1a_sex,cbcl_thought_M2c_sex,test="Chisq") #1a is better

# 1a sex: bic = 2133.1                          
# all: choose model 1a sex
amadmix_cbcl_thought_M1a_sex <- cbcl_thought_M1a_sex

### Sig Results ----
## no sig results                

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_c_thought) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(cbcl_thought_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_thought <- 1 - res_var/orig_Y_var
R2_thought

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(cbcl_thought_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(cbcl_thought_M1a_sex)$coef), #predictor names
                          summary(cbcl_thought_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$cbcl_thought_M1a_sex_Yhat <- as.numeric(predict(cbcl_thought_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_thought_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$cbcl_thought_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$cbcl_thought_M1a_sex_L1resid <- as.numeric(resid(cbcl_thought_M1a_sex))
# create Z score version
yr4_reg_data$Zcbcl_thought_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$cbcl_thought_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(cbcl_thought_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(cbcl_thought_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zcbcl_thought_M1a_sex_Yhat,
           y=Zcbcl_thought_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
cbcl_thought_M1a_sex_robustSE <- rlmer(res_c_thought ~ zcmc_prs + zcmc_age + zcmc_income +
                            sex_cmc_cisf +
                          (1|site),
                        data=yr4_reg_data, REML=FALSE)
summary(cbcl_thought_M1a_sex_robustSE)
summary(cbcl_thought_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_cbcl_thought_M1a_sex_robustSE <- cbcl_thought_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(cbcl_thought_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(cbcl_thought_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)


NOTE: THESE ARE PRETTY DIFFERENT 
NOTE: SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zcbcl_thought_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zcbcl_thought_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zcbcl_thought_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```

``` {amadmix ksads~prs and covar regressions - gad,r}

## GAD ----
### Intercept-Only Model Estimation (for Y) ----
ksads_gad_M0 <- lmer(res_k_gad ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(ksads_gad_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(ksads_gad_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in gad diagnoses is explained by site

### Random Intercept, Fixed Slopes without interactions ----
ksads_gad_M1a_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_gad_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
ksads_gad_M1b_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(ksads_gad_M1b_sex)

# ggplot(aes(x=zcmc_prs,y=res_c_thought),data=yr4_reg_data) +
ggplot(aes(x=zcmc_prs,y=zcmc_income),data=yr4_reg_data[which(yr4_reg_data$raw_k_ptsd==0),]) +
  geom_point() +
  geom_smooth(method="lm") +
  labs(x="PRS (Z Score)",y="Income-to-Needs Ratio (Z Score)",title="No GAD (Am Admix Ancestry)") +
  xlim(-7,7.6) +
  ylim(-2,5.1) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) 
# ggplot(aes(x=zcmc_prs,y=res_c_thought),data=yr4_reg_data) +
ggplot(aes(x=zcmc_prs,y=zcmc_income),data=yr4_reg_data[which(yr4_reg_data$raw_k_ptsd==1),]) +
  geom_point() +
  geom_smooth(method="lm") +
  labs(x="PRS (Z Score)",y="Income-to-Needs Ratio (Z Score)",title="GAD (Am Admix Ancestry)") +
  xlim(-7,7.6) +
  ylim(-2,5.1) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) 



### Random Intercept, random slopes, random effects uncorrelated without interactions ----
ksads_gad_M2a_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_gad_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
ksads_gad_M2b_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(ksads_gad_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
ksads_gad_M2c_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_gad_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
# ksads_gad_M2d_sex <- lmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                         zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
#                         zcmc_prs*sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_gad_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(ksads_gad_M1a_sex,ksads_gad_M1b_sex,test="Chisq")  #1a is better
anova(ksads_gad_M1b_sex,ksads_gad_M2a_sex,test="Chisq") #1b is better
anova(ksads_gad_M1b_sex,ksads_gad_M2b_sex,test="Chisq") #1b is better
anova(ksads_gad_M1b_sex,ksads_gad_M2c_sex,test="Chisq") #1b is better

# 1a sex: bic = 2844.3                
# all: choose model 1b sex
amadmix_ksads_gad_M1b_sex <- ksads_gad_M1b_sex

### Sig Results ----
## prs*income: p = 0.0147   , beta = 0.216234                       

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_k_gad) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(ksads_gad_M1b_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_gad <- 1 - res_var/orig_Y_var
R2_gad

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(ksads_gad_M1b_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(ksads_gad_M1b_sex)$coef), #predictor names
                          summary(ksads_gad_M1b_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$ksads_gad_M1a_sex_Yhat <- as.numeric(predict(ksads_gad_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_gad_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$ksads_gad_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$ksads_gad_M1a_sex_L1resid <- as.numeric(resid(ksads_gad_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_gad_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$ksads_gad_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(ksads_gad_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(ksads_gad_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zksads_gad_M1a_sex_Yhat,
           y=Zksads_gad_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
ksads_gad_M1a_sex_robustSE <- rlmer(res_k_gad ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_gad_M1a_sex_robustSE)
summary(ksads_gad_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_ksads_gad_M1a_sex_robustSE <- ksads_gad_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(ksads_gad_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(ksads_gad_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: SOME RESIDUALS ARE VERY VERY LARGE
NOTE: THESE ARE EXTREMELY DIFFERENT
NOTE: HEAVILY SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zksads_gad_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zksads_gad_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zksads_gad_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {amadmix ksads~prs and covar regressions - mdd,r}

## MDD ----
### Intercept-Only Model Estimation (for Y) ----
ksads_mdd_M0 <- lmer(res_k_mdd ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(ksads_mdd_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # 0.2% of the variance in mdd diagnoses is explained by site

### Random Intercept, Fixed Slopes without interactions ----
ksads_mdd_M1a_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
ksads_mdd_M1b_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs* zcmc_prs*
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M1b_sex)

### Random Intercept, random slopes, random effects uncorrelated without interactions ----
ksads_mdd_M2a_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_mdd_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
ksads_mdd_M2b_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(ksads_mdd_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
ksads_mdd_M2c_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_mdd_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
# sex failed to converge with either optimizer
ksads_mdd_M2d_sex <- lmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_mdd_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(ksads_mdd_M1a_sex,ksads_mdd_M1b_sex,test="Chisq")  #1a is better
anova(ksads_mdd_M1a_sex,ksads_mdd_M2a_sex,test="Chisq") #1a is better
anova(ksads_mdd_M1a_sex,ksads_mdd_M2b_sex,test="Chisq") #1a is better
anova(ksads_mdd_M1a_sex,ksads_mdd_M2c_sex,test="Chisq") #1a is better
anova(ksads_mdd_M1a_sex,ksads_mdd_M2d_sex,test="Chisq") #1a is better

# 1a sex: bic = 2801.4                  
# all: choose model 1a sex
amadmix_ksads_mdd_M1a_sex <- ksads_mdd_M1a_sex

### Sig Results ----
## cisf: p = 0.00306    , beta = 0.57960                            

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_k_mdd) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(ksads_mdd_M1a_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_mdd <- 1 - res_var/orig_Y_var
R2_mdd

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(ksads_mdd_M1a_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(ksads_mdd_M1a_sex)$coef), #predictor names
                          summary(ksads_mdd_M1a_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$ksads_mdd_M1a_sex_Yhat <- as.numeric(predict(ksads_mdd_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_mdd_M1a_sex_Yhat <- as.numeric(scale(yr4_reg_data$ksads_mdd_M1a_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$ksads_mdd_M1a_sex_L1resid <- as.numeric(resid(ksads_mdd_M1a_sex))
# create Z score version
yr4_reg_data$Zksads_mdd_M1a_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$ksads_mdd_M1a_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(ksads_mdd_M1a_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(ksads_mdd_M1a_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zksads_mdd_M1a_sex_Yhat,
           y=Zksads_mdd_M1a_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
ksads_mdd_M1a_sex_robustSE <- rlmer(res_k_mdd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_mdd_M1a_sex_robustSE)
summary(ksads_mdd_M1a_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_ksads_mdd_M1a_sex_robustSE <- ksads_mdd_M1a_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(ksads_mdd_M1a_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(ksads_mdd_M1a_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: SOME RESIDUALS ARE VERY VERY LARGE
NOTE: THESE ARE EXTREMELY DIFFERENT
NOTE: HEAVILY SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zksads_mdd_M1a_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zksads_mdd_M1a_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zksads_mdd_M1a_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))

```

``` {amadmix ksads~prs and covar regressions - ptsd,r}

## PTSD ----
### Intercept-Only Model Estimation (for Y) ----
ksads_ptsd_M0 <- lmer(res_k_ptsd ~ 1 + (1|site), data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M0)

### computing the ICC for Y using variance components ----
variances = as.data.frame(VarCorr(ksads_ptsd_M0))
cluster_var = variances[1,'vcov']
resid_var = variances[2,'vcov']
ICC_Y2 <- cluster_var/(cluster_var + resid_var)
ICC_Y2 # <0.01% of the variance in ptsd diagnoses is explained by site

### Random Intercept, Fixed Slopes without interactions ----
ksads_ptsd_M1a_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M1a_sex)

### Random Intercept, Fixed Slopes with interactions ----
ksads_ptsd_M1b_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf +
                      (1|site),
                    data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M1b_sex)

# ggplot(aes(x=zcmc_prs,y=res_c_thought),data=yr4_reg_data) +
ggplot(aes(x=zcmc_prs,y=(age/12)),data=yr4_reg_data[which(yr4_reg_data$raw_k_ptsd==0),]) +
  geom_point() +
  geom_smooth(method="lm") +
  labs(x="PRS (Z Score)",y="Age",title="No PTSD (Am Admix Ancestry)") +
  xlim(-7,7.6) +
  ylim(12.5,15.7) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) 
# ggplot(aes(x=zcmc_prs,y=res_c_thought),data=yr4_reg_data) +
ggplot(aes(x=zcmc_prs,y=(age/12)),data=yr4_reg_data[which(yr4_reg_data$raw_k_ptsd==1),]) +
  geom_point() +
  geom_smooth(method="lm") +
  labs(x="PRS (Z Score)",y="Age",title="PTSD (Am Admix Ancestry)") +
  xlim(-7,7.6) +
  ylim(12.5,15.7) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) 

ggplot(aes(x=zcmc_prs,fill=as.factor(raw_k_ptsd)),data=yr4_reg_data) +
  geom_histogram(binwidth=0.5) +
  labs(x="PRS (Z Score)",y="Count",title="Am Admix Ancestry",fill="GAD") +
  geom_vline(xintercept=-1.200471,color="blue") +
  geom_vline(xintercept=0.03260305,color="black") +
  # xlim(-7,8) +
  scale_y_continuous(expand=c(0,0),limits=c(0,55)) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) 

# Define the number of bins and their width
num_bins <- 10  # You can adjust this value as needed
bin_width <- (max(yr4_reg_data$zcmc_prs) - min(yr4_reg_data$zcmc_prs)) / num_bins

# Step 1: Bin zcmc_prs
df_binned <- yr4_reg_data %>%
  mutate(zcmc_prs_bin = cut(zcmc_prs, breaks = seq(min(zcmc_prs), max(zcmc_prs), bin_width), include.lowest = TRUE))

df_proportions <- df_binned %>%
  group_by(zcmc_prs_bin) %>%
  summarise(prop_1s = mean(raw_k_ptsd == 1))


### Random Intercept, random slopes, random effects uncorrelated without interactions ----
ksads_ptsd_M2a_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_ptsd_M2a_sex)

### Random Intercept, random slopes, random effects uncorrelated with interactions ----
ksads_ptsd_M2b_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf + 
                      (1|site)+(0+zcmc_prs|site)+
                      (0+zcmc_income|site)+(0+zcmc_age|site)+
                      (0+sex_cmc_cisf|site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
summary(ksads_ptsd_M2b_sex)

### Random Intercept, random slopes, random effects free to correlate without interactions ----
# sex failed to converge with either optimizer
# ksads_ptsd_M2c_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
#                         sex_cmc_cisf +
#                       (1+zcmc_prs+zcmc_income+zcmc_age+
#                         sex_cmc_cisf |site),
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
#                     # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
# summary(ksads_ptsd_M2c_sex)

### Random Intercept, random slopes, random effects free to correlate with interactions ----
ksads_ptsd_M2d_sex <- lmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                        sex_cmc_cisf +
                        zcmc_prs*zcmc_age + zcmc_prs*zcmc_income +
                        zcmc_prs*sex_cmc_cisf +
                      (1+zcmc_prs+zcmc_income+zcmc_age+
                        sex_cmc_cisf |site),
                    data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="bobyqa"))
                    # data=yr4_reg_data, REML=FALSE,control=lmerControl(optimizer="Nelder_Mead"))
summary(ksads_ptsd_M2d_sex)

### Model Comparisons of AIC/BIC fit indices and Likelihood Ratio Test (LRT) ----
anova(ksads_ptsd_M1a_sex,ksads_ptsd_M1b_sex,test="Chisq")  #1b is better
anova(ksads_ptsd_M1b_sex,ksads_ptsd_M2a_sex,test="Chisq") #1b is better
anova(ksads_ptsd_M1b_sex,ksads_ptsd_M2b_sex,test="Chisq") #1b is better
anova(ksads_ptsd_M1b_sex,ksads_ptsd_M2d_sex,test="Chisq") #1b is better

# 2b sex: bic = 3000.3                  
# all: choose model 1b sex
amadmix_ksads_ptsd_M1b_sex <- ksads_ptsd_M1b_sex

### Sig Results ----
## prs: p = 0.02790 , beta = -0.245753   
## prs*age: p = 0.00933 , beta = 0.285021   
## prs*cisf: p = 0.03809 , beta = -0.240455        

### ext variance explained by model (r^2) ----
#### 1 - ((residual variance)/(original ext variance)) # 1 - % unexplained variance = % explained
#### orig_Y_var = var(datamadmixame$outcome) to get original Y variance
orig_Y_var = var(yr4_reg_data$res_k_ptsd) 
orig_Y_var
#### model_variances = as.data.frame(VarCorr(modelnamehere)) to obtain variance estimates
model_variances = as.data.frame(VarCorr(ksads_ptsd_M1b_sex)) 
model_variances
#### res_var = model_variances[rownumber,'vcov'] to get L1 residual variance; look at model_variances first
res_var = model_variances[2,'vcov'] 
res_var
#### calculate
R2_ptsd <- 1 - res_var/orig_Y_var
R2_ptsd

## variance explained by each predictor (sr^2) ----
### sr^2 = squared semi-partial correlation
### % of variance in Y "uniquely" explained by that predictor (not overlapping with other Xs)
### extract residual df 
res_df <- as.numeric(summary(ksads_ptsd_M1b_sex)$AICtab[5])
res_df 
### extract t-values
tvals <- data.frame(cbind(row.names(summary(ksads_ptsd_M1b_sex)$coef), #predictor names
                          summary(ksads_ptsd_M1b_sex)$coef[,4]) #t values
              )
colnames(tvals) <- c("predictor","tval")
tvals$tval <- as.numeric(tvals$tval)
### now compute the approx sr^2 values
sr2vals <- tvals %>% 
                    mutate(sr2 = ((tvals$tval**2/(tvals$tval**2+res_df))*(1-R2_thought))/
                      (1- (tvals$tval**2/(tvals$tval**2+res_df)))) %>%
                    mutate(percent_sr2 = sr2*100)
sr2vals

# Extract L1 Predicted and Residual Values to Add to Main L1 Dataset ----
### predicted values (Yhats)
yr4_reg_data$ksads_ptsd_M1b_sex_Yhat <- as.numeric(predict(ksads_ptsd_M1b_sex))
# create Z score version
yr4_reg_data$Zksads_ptsd_M1b_sex_Yhat <- as.numeric(scale(yr4_reg_data$ksads_ptsd_M1b_sex_Yhat))
### residual values (the r's, Y - Yhat)
yr4_reg_data$ksads_ptsd_M1b_sex_L1resid <- as.numeric(resid(ksads_ptsd_M1b_sex))
# create Z score version
yr4_reg_data$Zksads_ptsd_M1b_sex_L1resid <- as.numeric(
                                                scale(yr4_reg_data$ksads_ptsd_M1b_sex_L1resid))

## Extract L2 Predicted and Residual Values to Add to Previously Built L2 Aggregate Dataset ----
### no L2 predictors so only normality and independence assessed
### extract L2 residuals using ranef() function
intercept <- ranef(ksads_ptsd_M1b_sex)$site["(Intercept)"] #intercept is always as "(Intercept)"
colnames(intercept) = c("RE_int")
rownames(intercept) <- NULL
intercept$ZRE_int <- as.numeric(scale(intercept$RE_int), scale = TRUE)
RE_file <- intercept
RE_file$site <- row.names(ranef(ksads_ptsd_M1b_sex)$site)

## Assumption #1 and 2 Linearity and Heteroskedasticity ----
### visually inspect residual-predicted plot for evidence of curvilinearity
### level 1 ----

ggplot(aes(x=Zksads_ptsd_M1b_sex_Yhat,
           y=Zksads_ptsd_M1b_sex_L1resid),data=yr4_reg_data) +
  geom_point(aes(color=sex)) +
  labs(x="Predicted Values (Z)",y="Residual Values (Z)") +
  geom_smooth(method="lm",color="black") +
  theme_bw()

### (if fan shape)
### Robust SEs ----
### Lets move forward now to estimate our model using robust SEs that are fitted using an 
### iterative algorithm that down-weights outliers and assumes no normality of the data.
### general: use rlmer() function from robustlmm package, instead of lmer() in lme4 package
### note that this function takes a few minutes to estimate, keep your patience hat on /!\ 
ksads_ptsd_M1b_sex_robustSE <- rlmer(res_k_ptsd ~ zcmc_prs + zcmc_age + zcmc_income +
                              sex_cmc_cisf +
                            (1|site),
                          data=yr4_reg_data, REML=FALSE)
summary(ksads_ptsd_M1b_sex_robustSE)
summary(ksads_ptsd_M1b_sex) # for comparison with the robust estimate
### results substantively the same (what was significant remains sig, what was not is not sig)
### so, non-normality present in our data does not alter our conclusions
amadmix_ksads_ptsd_M1b_sex_robustSE <- ksads_ptsd_M1b_sex_robustSE
# similar enough that fan pattern not concerning

data.frame(summary(ksads_ptsd_M1b_sex_robustSE)$coefficients) %>%
  rename(robust_est = Estimate,
         robust_se = Std..Error,
         robust_tval = t.value) %>%
  bind_cols(summary(ksads_ptsd_M1b_sex)$coef) %>%
  rename(notrobust_est = Estimate,
         notrobust_se = `Std. Error`,
         notrobust_df = `df`,
         notrobust_tval = `t value`,
         notrobust_pval = `Pr(>|t|)`) %>%
  select(robust_est,notrobust_est,
         robust_se,notrobust_se,
         robust_tval,notrobust_tval,
         notrobust_df,notrobust_pval)

NOTE: SOME RESIDUALS ARE VERY VERY LARGE
NOTE: THESE ARE EXTREMELY DIFFERENT
NOTE: HEAVILY SKEWED 


## Assumption #2 Normality ----
### visually inspect residuals (skew/kurtosis tests can miss multimodality!) ----
### check L1 residuals
hist(yr4_reg_data$Zksads_ptsd_M1b_sex_L1resid)

### check L2 residuals **from 2L** file
hist(RE_file$ZRE_int)

### formal statistical tests of skew and kurtosis
#### level 1 residuals
agostino.test(yr4_reg_data$Zksads_ptsd_M1b_sex_L1resid, alternative = c("two.sided"))
anscombe.test(yr4_reg_data$Zksads_ptsd_M1b_sex_L1resid, alternative = c("two.sided"))
#### level 2 residuals
agostino.test(RE_file$ZRE_int, alternative = c("two.sided"))
anscombe.test(RE_file$ZRE_int, alternative = c("two.sided"))
```
